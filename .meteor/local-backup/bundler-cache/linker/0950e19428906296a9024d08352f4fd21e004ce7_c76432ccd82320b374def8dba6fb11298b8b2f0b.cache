[{"type":"js","data":"Package[\"core-runtime\"].queue(\"blaze\",function () {/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar EmitterPromise = Package.meteor.EmitterPromise;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar ObserveSequence = Package['observe-sequence'].ObserveSequence;\nvar ReactiveVar = Package['reactive-var'].ReactiveVar;\nvar OrderedDict = Package['ordered-dict'].OrderedDict;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar HTML = Package.htmljs.HTML;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar Blaze, UI, Handlebars;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"blaze\":{\"preamble.js\":function module(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/preamble.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/**\n * @namespace Blaze\n * @summary The namespace for all Blaze-related methods and classes.\n */\nBlaze = {};\n\n// Utility to HTML-escape a string.  Included for legacy reasons.\n// TODO: Should be replaced with _.escape once underscore is upgraded to a newer\n//       version which escapes ` (backtick) as well. Underscore 1.5.2 does not.\nBlaze._escape = function () {\n  const escape_map = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"/\": \"&#x2F;\",\n    \"`\": \"&#x60;\",\n    /* IE allows backtick-delimited attributes?? */\n    \"&\": \"&amp;\"\n  };\n  const escape_one = function (c) {\n    return escape_map[c];\n  };\n  return function (x) {\n    return x.replace(/[&<>\"'`]/g, escape_one);\n  };\n}();\nBlaze._warn = function (msg) {\n  msg = 'Warning: ' + msg;\n  if (typeof console !== 'undefined' && console.warn) {\n    console.warn(msg);\n  }\n};\nconst nativeBind = Function.prototype.bind;\n\n// An implementation of _.bind which allows better optimization.\n// See: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\nif (nativeBind) {\n  Blaze._bind = function (func, obj) {\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    if (arguments.length === 2) {\n      return nativeBind.call(func, obj);\n    }\n    const args = [obj, ...rest];\n    return nativeBind.apply(func, args);\n  };\n} else {\n  // A slower but backwards compatible version.\n  Blaze._bind = function (objA, objB) {\n    objA.bind(objB);\n  };\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"exceptions.js\":function module(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/exceptions.js                                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nlet debugFunc;\n\n// We call into user code in many places, and it's nice to catch exceptions\n// propagated from user code immediately so that the whole system doesn't just\n// break.  Catching exceptions is easy; reporting them is hard.  This helper\n// reports exceptions.\n//\n// Usage:\n//\n// ```\n// try {\n//   // ... someStuff ...\n// } catch (e) {\n//   reportUIException(e);\n// }\n// ```\n//\n// An optional second argument overrides the default message.\n\n// Set this to `true` to cause `reportException` to throw\n// the next exception rather than reporting it.  This is\n// useful in unit tests that test error messages.\nBlaze._throwNextException = false;\nBlaze._reportException = function (e, msg) {\n  if (Blaze._throwNextException) {\n    Blaze._throwNextException = false;\n    throw e;\n  }\n  if (!debugFunc)\n    // adapted from Tracker\n    debugFunc = function () {\n      return typeof Meteor !== \"undefined\" ? Meteor._debug : typeof console !== \"undefined\" && console.log ? console.log : function () {};\n    };\n\n  // In Chrome, `e.stack` is a multiline string that starts with the message\n  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.\n  // `console.log` supplies the space between the two arguments.\n  debugFunc()(msg || 'Exception caught in template:', e.stack || e.message || e);\n};\n\n// It's meant to be used in `Promise` chains to report the error while not\n// \"swallowing\" it (i.e., the chain will still reject).\nBlaze._reportExceptionAndThrow = function (error) {\n  Blaze._reportException(error);\n  throw error;\n};\nBlaze._wrapCatchingExceptions = function (f, where) {\n  if (typeof f !== 'function') return f;\n  return function () {\n    try {\n      for (var _len = arguments.length, _arguments = new Array(_len), _key = 0; _key < _len; _key++) {\n        _arguments[_key] = arguments[_key];\n      }\n      return f.apply(this, _arguments);\n    } catch (e) {\n      Blaze._reportException(e, 'Exception in ' + where + ':');\n    }\n  };\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"view.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/view.js                                                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let HTML;\n    module.link(\"meteor/htmljs\", {\n      HTML(v) {\n        HTML = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    /**\n     * A binding is either `undefined` (pending), `{ error }` (rejected), or\n     * `{ value }` (resolved). Synchronous values are immediately resolved (i.e.,\n     * `{ value }` is used). The other states are reserved for asynchronous bindings\n     * (i.e., values wrapped with `Promise`s).\n     * @typedef {{ error: unknown } | { value: unknown } | undefined} Binding\n     */\n\n    /**\n     * @class\n     * @summary Constructor for a View, which represents a reactive region of DOM.\n     * @locus Client\n     * @param {String} [name] Optional.  A name for this type of View.  See [`view.name`](#view_name).\n     * @param {Function} renderFunction A function that returns [*renderable content*](#Renderable-Content).  In this function, `this` is bound to the View.\n     */\n    Blaze.View = function (name, render) {\n      if (!(this instanceof Blaze.View))\n        // called without `new`\n        return new Blaze.View(name, render);\n      if (typeof name === 'function') {\n        // omitted \"name\" argument\n        render = name;\n        name = '';\n      }\n      this.name = name;\n      this._render = render;\n      this._callbacks = {\n        created: null,\n        rendered: null,\n        destroyed: null\n      };\n\n      // Setting all properties here is good for readability,\n      // and also may help Chrome optimize the code by keeping\n      // the View object from changing shape too much.\n      this.isCreated = false;\n      this._isCreatedForExpansion = false;\n      this.isRendered = false;\n      this._isAttached = false;\n      this.isDestroyed = false;\n      this._isInRender = false;\n      this.parentView = null;\n      this._domrange = null;\n      // This flag is normally set to false except for the cases when view's parent\n      // was generated as part of expanding some syntactic sugar expressions or\n      // methods.\n      // Ex.: Blaze.renderWithData is an equivalent to creating a view with regular\n      // Blaze.render and wrapping it into {{#with data}}{{/with}} view. Since the\n      // users don't know anything about these generated parent views, Blaze needs\n      // this information to be available on views to make smarter decisions. For\n      // example: removing the generated parent view with the view on Blaze.remove.\n      this._hasGeneratedParent = false;\n      // Bindings accessible to children views (via view.lookup('name')) within the\n      // closest template view.\n      /** @type {Record<string, ReactiveVar<Binding>>} */\n      this._scopeBindings = {};\n      this.renderCount = 0;\n    };\n    Blaze.View.prototype._render = function () {\n      return null;\n    };\n    Blaze.View.prototype.onViewCreated = function (cb) {\n      this._callbacks.created = this._callbacks.created || [];\n      this._callbacks.created.push(cb);\n    };\n    Blaze.View.prototype._onViewRendered = function (cb) {\n      this._callbacks.rendered = this._callbacks.rendered || [];\n      this._callbacks.rendered.push(cb);\n    };\n    Blaze.View.prototype.onViewReady = function (cb) {\n      const self = this;\n      const fire = function () {\n        Tracker.afterFlush(function () {\n          if (!self.isDestroyed) {\n            Blaze._withCurrentView(self, function () {\n              cb.call(self);\n            });\n          }\n        });\n      };\n      self._onViewRendered(function onViewRendered() {\n        if (self.isDestroyed) return;\n        if (!self._domrange.attached) self._domrange.onAttached(fire);else fire();\n      });\n    };\n    Blaze.View.prototype.onViewDestroyed = function (cb) {\n      this._callbacks.destroyed = this._callbacks.destroyed || [];\n      this._callbacks.destroyed.push(cb);\n    };\n    Blaze.View.prototype.removeViewDestroyedListener = function (cb) {\n      const destroyed = this._callbacks.destroyed;\n      if (!destroyed) return;\n      const index = destroyed.lastIndexOf(cb);\n      if (index !== -1) {\n        // XXX You'd think the right thing to do would be splice, but _fireCallbacks\n        // gets sad if you remove callbacks while iterating over the list.  Should\n        // change this to use callback-hook or EventEmitter or something else that\n        // properly supports removal.\n        destroyed[index] = null;\n      }\n    };\n\n    /// View#autorun(func)\n    ///\n    /// Sets up a Tracker autorun that is \"scoped\" to this View in two\n    /// important ways: 1) Blaze.currentView is automatically set\n    /// on every re-run, and 2) the autorun is stopped when the\n    /// View is destroyed.  As with Tracker.autorun, the first run of\n    /// the function is immediate, and a Computation object that can\n    /// be used to stop the autorun is returned.\n    ///\n    /// View#autorun is meant to be called from View callbacks like\n    /// onViewCreated, or from outside the rendering process.  It may not\n    /// be called before the onViewCreated callbacks are fired (too early),\n    /// or from a render() method (too confusing).\n    ///\n    /// Typically, autoruns that update the state\n    /// of the View (as in Blaze.With) should be started from an onViewCreated\n    /// callback.  Autoruns that update the DOM should be started\n    /// from either onViewCreated (guarded against the absence of\n    /// view._domrange), or onViewReady.\n    Blaze.View.prototype.autorun = function (f, _inViewScope, displayName) {\n      const self = this;\n\n      // The restrictions on when View#autorun can be called are in order\n      // to avoid bad patterns, like creating a Blaze.View and immediately\n      // calling autorun on it.  A freshly created View is not ready to\n      // have logic run on it; it doesn't have a parentView, for example.\n      // It's when the View is materialized or expanded that the onViewCreated\n      // handlers are fired and the View starts up.\n      //\n      // Letting the render() method call `this.autorun()` is problematic\n      // because of re-render.  The best we can do is to stop the old\n      // autorun and start a new one for each render, but that's a pattern\n      // we try to avoid internally because it leads to helpers being\n      // called extra times, in the case where the autorun causes the\n      // view to re-render (and thus the autorun to be torn down and a\n      // new one established).\n      //\n      // We could lift these restrictions in various ways.  One interesting\n      // idea is to allow you to call `view.autorun` after instantiating\n      // `view`, and automatically wrap it in `view.onViewCreated`, deferring\n      // the autorun so that it starts at an appropriate time.  However,\n      // then we can't return the Computation object to the caller, because\n      // it doesn't exist yet.\n      if (!self.isCreated) {\n        throw new Error(\"View#autorun must be called from the created callback at the earliest\");\n      }\n      if (this._isInRender) {\n        throw new Error(\"Can't call View#autorun from inside render(); try calling it from the created or rendered callback\");\n      }\n      const templateInstanceFunc = Blaze.Template._currentTemplateInstanceFunc;\n      const func = function viewAutorun(c) {\n        return Blaze._withCurrentView(_inViewScope || self, function () {\n          return Blaze.Template._withTemplateInstanceFunc(templateInstanceFunc, function () {\n            return f.call(self, c);\n          });\n        });\n      };\n\n      // Give the autorun function a better name for debugging and profiling.\n      // The `displayName` property is not part of the spec but browsers like Chrome\n      // and Firefox prefer it in debuggers over the name function was declared by.\n      func.displayName = (self.name || 'anonymous') + ':' + (displayName || 'anonymous');\n      const comp = Tracker.autorun(func);\n      const stopComputation = function () {\n        comp.stop();\n      };\n      self.onViewDestroyed(stopComputation);\n      comp.onStop(function () {\n        self.removeViewDestroyedListener(stopComputation);\n      });\n      return comp;\n    };\n    Blaze.View.prototype._errorIfShouldntCallSubscribe = function () {\n      const self = this;\n      if (!self.isCreated) {\n        throw new Error(\"View#subscribe must be called from the created callback at the earliest\");\n      }\n      if (self._isInRender) {\n        throw new Error(\"Can't call View#subscribe from inside render(); try calling it from the created or rendered callback\");\n      }\n      if (self.isDestroyed) {\n        throw new Error(\"Can't call View#subscribe from inside the destroyed callback, try calling it inside created or rendered.\");\n      }\n    };\n\n    /**\n     * Just like Blaze.View#autorun, but with Meteor.subscribe instead of\n     * Tracker.autorun. Stop the subscription when the view is destroyed.\n     * @return {SubscriptionHandle} A handle to the subscription so that you can\n     * see if it is ready, or stop it manually\n     */\n    Blaze.View.prototype.subscribe = function (args, options) {\n      const self = this;\n      options = options || {};\n      self._errorIfShouldntCallSubscribe();\n      let subHandle;\n      if (options.connection) {\n        subHandle = options.connection.subscribe.apply(options.connection, args);\n      } else {\n        subHandle = Meteor.subscribe.apply(Meteor, args);\n      }\n      self.onViewDestroyed(function () {\n        subHandle.stop();\n      });\n      return subHandle;\n    };\n    Blaze.View.prototype.firstNode = function () {\n      if (!this._isAttached) throw new Error(\"View must be attached before accessing its DOM\");\n      return this._domrange.firstNode();\n    };\n    Blaze.View.prototype.lastNode = function () {\n      if (!this._isAttached) throw new Error(\"View must be attached before accessing its DOM\");\n      return this._domrange.lastNode();\n    };\n    Blaze._fireCallbacks = function (view, which) {\n      Blaze._withCurrentView(view, function () {\n        Tracker.nonreactive(function fireCallbacks() {\n          const cbs = view._callbacks[which];\n          for (let i = 0, N = cbs && cbs.length; i < N; i++) cbs[i] && cbs[i].call(view);\n        });\n      });\n    };\n    Blaze._createView = function (view, parentView, forExpansion) {\n      if (view.isCreated) throw new Error(\"Can't render the same View twice\");\n      view.parentView = parentView || null;\n      view.isCreated = true;\n      if (forExpansion) view._isCreatedForExpansion = true;\n      Blaze._fireCallbacks(view, 'created');\n    };\n    const doFirstRender = function (view, initialContent) {\n      const domrange = new Blaze._DOMRange(initialContent);\n      view._domrange = domrange;\n      domrange.view = view;\n      view.isRendered = true;\n      Blaze._fireCallbacks(view, 'rendered');\n      let teardownHook = null;\n      domrange.onAttached(function attached(range, element) {\n        view._isAttached = true;\n        teardownHook = Blaze._DOMBackend.Teardown.onElementTeardown(element, function teardown() {\n          Blaze._destroyView(view, true /* _skipNodes */);\n        });\n      });\n\n      // tear down the teardown hook\n      view.onViewDestroyed(function () {\n        if (teardownHook) teardownHook.stop();\n        teardownHook = null;\n      });\n      return domrange;\n    };\n\n    // Take an uncreated View `view` and create and render it to DOM,\n    // setting up the autorun that updates the View.  Returns a new\n    // DOMRange, which has been associated with the View.\n    //\n    // The private arguments `_workStack` and `_intoArray` are passed in\n    // by Blaze._materializeDOM and are only present for recursive calls\n    // (when there is some other _materializeView on the stack).  If\n    // provided, then we avoid the mutual recursion of calling back into\n    // Blaze._materializeDOM so that deep View hierarchies don't blow the\n    // stack.  Instead, we push tasks onto workStack for the initial\n    // rendering and subsequent setup of the View, and they are done after\n    // we return.  When there is a _workStack, we do not return the new\n    // DOMRange, but instead push it into _intoArray from a _workStack\n    // task.\n    Blaze._materializeView = function (view, parentView, _workStack, _intoArray) {\n      Blaze._createView(view, parentView);\n      let domrange;\n      let lastHtmljs;\n      // We don't expect to be called in a Computation, but just in case,\n      // wrap in Tracker.nonreactive.\n      Tracker.nonreactive(function () {\n        view.autorun(function doRender(c) {\n          // `view.autorun` sets the current view.\n          view.renderCount = view.renderCount + 1;\n          view._isInRender = true;\n          // Any dependencies that should invalidate this Computation come\n          // from this line:\n          const htmljs = view._render();\n          view._isInRender = false;\n          if (!c.firstRun && !Blaze._isContentEqual(lastHtmljs, htmljs)) {\n            Tracker.nonreactive(function doMaterialize() {\n              // re-render\n              const rangesAndNodes = Blaze._materializeDOM(htmljs, [], view);\n              domrange.setMembers(rangesAndNodes);\n              Blaze._fireCallbacks(view, 'rendered');\n            });\n          }\n          lastHtmljs = htmljs;\n\n          // Causes any nested views to stop immediately, not when we call\n          // `setMembers` the next time around the autorun.  Otherwise,\n          // helpers in the DOM tree to be replaced might be scheduled\n          // to re-run before we have a chance to stop them.\n          Tracker.onInvalidate(function () {\n            if (domrange) {\n              domrange.destroyMembers();\n            }\n          });\n        }, undefined, 'materialize');\n\n        // first render.  lastHtmljs is the first htmljs.\n        let initialContents;\n        if (!_workStack) {\n          initialContents = Blaze._materializeDOM(lastHtmljs, [], view);\n          domrange = doFirstRender(view, initialContents);\n          initialContents = null; // help GC because we close over this scope a lot\n        } else {\n          // We're being called from Blaze._materializeDOM, so to avoid\n          // recursion and save stack space, provide a description of the\n          // work to be done instead of doing it.  Tasks pushed onto\n          // _workStack will be done in LIFO order after we return.\n          // The work will still be done within a Tracker.nonreactive,\n          // because it will be done by some call to Blaze._materializeDOM\n          // (which is always called in a Tracker.nonreactive).\n          initialContents = [];\n          // push this function first so that it happens last\n          _workStack.push(function () {\n            domrange = doFirstRender(view, initialContents);\n            initialContents = null; // help GC because of all the closures here\n            _intoArray.push(domrange);\n          });\n          // now push the task that calculates initialContents\n          _workStack.push(Blaze._bind(Blaze._materializeDOM, null, lastHtmljs, initialContents, view, _workStack));\n        }\n      });\n      if (!_workStack) {\n        return domrange;\n      } else {\n        return null;\n      }\n    };\n\n    // Expands a View to HTMLjs, calling `render` recursively on all\n    // Views and evaluating any dynamic attributes.  Calls the `created`\n    // callback, but not the `materialized` or `rendered` callbacks.\n    // Destroys the view immediately, unless called in a Tracker Computation,\n    // in which case the view will be destroyed when the Computation is\n    // invalidated.  If called in a Tracker Computation, the result is a\n    // reactive string; that is, the Computation will be invalidated\n    // if any changes are made to the view or subviews that might affect\n    // the HTML.\n    Blaze._expandView = function (view, parentView) {\n      Blaze._createView(view, parentView, true /*forExpansion*/);\n      view._isInRender = true;\n      const htmljs = Blaze._withCurrentView(view, function () {\n        return view._render();\n      });\n      view._isInRender = false;\n      const result = Blaze._expand(htmljs, view);\n      if (Tracker.active) {\n        Tracker.onInvalidate(function () {\n          Blaze._destroyView(view);\n        });\n      } else {\n        Blaze._destroyView(view);\n      }\n      return result;\n    };\n\n    // Options: `parentView`\n    Blaze._HTMLJSExpander = HTML.TransformingVisitor.extend();\n    Blaze._HTMLJSExpander.def({\n      visitObject: function (x) {\n        if (x instanceof Blaze.Template) x = x.constructView();\n        if (x instanceof Blaze.View) return Blaze._expandView(x, this.parentView);\n\n        // this will throw an error; other objects are not allowed!\n        return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n      },\n      visitAttributes: function (attrs) {\n        // expand dynamic attributes\n        if (typeof attrs === 'function') attrs = Blaze._withCurrentView(this.parentView, attrs);\n\n        // call super (e.g. for case where `attrs` is an array)\n        return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\n      },\n      visitAttribute: function (name, value, tag) {\n        // expand attribute values that are functions.  Any attribute value\n        // that contains Views must be wrapped in a function.\n        if (typeof value === 'function') value = Blaze._withCurrentView(this.parentView, value);\n        return HTML.TransformingVisitor.prototype.visitAttribute.call(this, name, value, tag);\n      }\n    });\n\n    // Return Blaze.currentView, but only if it is being rendered\n    // (i.e. we are in its render() method).\n    const currentViewIfRendering = function () {\n      const view = Blaze.currentView;\n      return view && view._isInRender ? view : null;\n    };\n    Blaze._expand = function (htmljs, parentView) {\n      parentView = parentView || currentViewIfRendering();\n      return new Blaze._HTMLJSExpander({\n        parentView: parentView\n      }).visit(htmljs);\n    };\n    Blaze._expandAttributes = function (attrs, parentView) {\n      parentView = parentView || currentViewIfRendering();\n      const expanded = new Blaze._HTMLJSExpander({\n        parentView: parentView\n      }).visitAttributes(attrs);\n      return expanded || {};\n    };\n    Blaze._destroyView = function (view, _skipNodes) {\n      if (view.isDestroyed) return;\n      view.isDestroyed = true;\n\n      // Destroy views and elements recursively.  If _skipNodes,\n      // only recurse up to views, not elements, for the case where\n      // the backend (jQuery) is recursing over the elements already.\n\n      if (view._domrange) view._domrange.destroyMembers(_skipNodes);\n\n      // XXX: fire callbacks after potential members are destroyed\n      // otherwise it's tracker.flush will cause the above line will\n      // not be called and their views won't be destroyed\n      // Involved issues: DOMRange \"Must be attached\" error, mem leak\n\n      Blaze._fireCallbacks(view, 'destroyed');\n    };\n    Blaze._destroyNode = function (node) {\n      if (node.nodeType === 1) Blaze._DOMBackend.Teardown.tearDownElement(node);\n    };\n\n    // Are the HTMLjs entities `a` and `b` the same?  We could be\n    // more elaborate here but the point is to catch the most basic\n    // cases.\n    Blaze._isContentEqual = function (a, b) {\n      if (a instanceof HTML.Raw) {\n        return b instanceof HTML.Raw && a.value === b.value;\n      } else if (a == null) {\n        return b == null;\n      } else {\n        return a === b && (typeof a === 'number' || typeof a === 'boolean' || typeof a === 'string');\n      }\n    };\n\n    /**\n     * @summary The View corresponding to the current template helper, event handler, callback, or autorun.  If there isn't one, `null`.\n     * @locus Client\n     * @type {Blaze.View}\n     */\n    Blaze.currentView = null;\n\n    /**\n     * @template T\n     * @param {Blaze.View} view\n     * @param {function(): T} func\n     * @returns {T}\n     */\n    Blaze._withCurrentView = function (view, func) {\n      const oldView = Blaze.currentView;\n      try {\n        Blaze.currentView = view;\n        return func();\n      } finally {\n        Blaze.currentView = oldView;\n      }\n    };\n\n    // Blaze.render publicly takes a View or a Template.\n    // Privately, it takes any HTMLJS (extended with Views and Templates)\n    // except null or undefined, or a function that returns any extended\n    // HTMLJS.\n    const checkRenderContent = function (content) {\n      if (content === null) throw new Error(\"Can't render null\");\n      if (typeof content === 'undefined') throw new Error(\"Can't render undefined\");\n      if (content instanceof Blaze.View || content instanceof Blaze.Template || typeof content === 'function') return;\n      try {\n        // Throw if content doesn't look like HTMLJS at the top level\n        // (i.e. verify that this is an HTML.Tag, or an array,\n        // or a primitive, etc.)\n        new HTML.Visitor().visit(content);\n      } catch (e) {\n        // Make error message suitable for public API\n        throw new Error(\"Expected Template or View\");\n      }\n    };\n\n    // For Blaze.render and Blaze.toHTML, take content and\n    // wrap it in a View, unless it's a single View or\n    // Template already.\n    const contentAsView = function (content) {\n      checkRenderContent(content);\n      if (content instanceof Blaze.Template) {\n        return content.constructView();\n      } else if (content instanceof Blaze.View) {\n        return content;\n      } else {\n        let func = content;\n        if (typeof func !== 'function') {\n          func = function () {\n            return content;\n          };\n        }\n        return Blaze.View('render', func);\n      }\n    };\n\n    // For Blaze.renderWithData and Blaze.toHTMLWithData, wrap content\n    // in a function, if necessary, so it can be a content arg to\n    // a Blaze.With.\n    const contentAsFunc = function (content) {\n      checkRenderContent(content);\n      if (typeof content !== 'function') {\n        return function () {\n          return content;\n        };\n      } else {\n        return content;\n      }\n    };\n    Blaze.__rootViews = [];\n\n    /**\n     * @summary Renders a template or View to DOM nodes and inserts it into the DOM, returning a rendered [View](#Blaze-View) which can be passed to [`Blaze.remove`](#Blaze-remove).\n     * @locus Client\n     * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.  If a template, a View object is [constructed](#template_constructview).  If a View, it must be an unrendered View, which becomes a rendered View and is returned.\n     * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n     * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n     * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n     */\n    Blaze.render = function (content, parentElement, nextNode, parentView) {\n      if (!parentElement) {\n        Blaze._warn(\"Blaze.render without a parent element is deprecated. \" + \"You must specify where to insert the rendered content.\");\n      }\n      if (nextNode instanceof Blaze.View) {\n        // handle omitted nextNode\n        parentView = nextNode;\n        nextNode = null;\n      }\n\n      // parentElement must be a DOM node. in particular, can't be the\n      // result of a call to `$`. Can't check if `parentElement instanceof\n      // Node` since 'Node' is undefined in IE8.\n      if (parentElement && typeof parentElement.nodeType !== 'number') throw new Error(\"'parentElement' must be a DOM node\");\n      if (nextNode && typeof nextNode.nodeType !== 'number')\n        // 'nextNode' is optional\n        throw new Error(\"'nextNode' must be a DOM node\");\n      parentView = parentView || currentViewIfRendering();\n      const view = contentAsView(content);\n\n      // TODO: this is only needed in development\n      if (!parentView) {\n        view.onViewCreated(function () {\n          Blaze.__rootViews.push(view);\n        });\n        view.onViewDestroyed(function () {\n          let index = Blaze.__rootViews.indexOf(view);\n          if (index > -1) {\n            Blaze.__rootViews.splice(index, 1);\n          }\n        });\n      }\n      Blaze._materializeView(view, parentView);\n      if (parentElement) {\n        view._domrange.attach(parentElement, nextNode);\n      }\n      return view;\n    };\n    Blaze.insert = function (view, parentElement, nextNode) {\n      Blaze._warn(\"Blaze.insert has been deprecated.  Specify where to insert the \" + \"rendered content in the call to Blaze.render.\");\n      if (!(view && view._domrange instanceof Blaze._DOMRange)) throw new Error(\"Expected template rendered with Blaze.render\");\n      view._domrange.attach(parentElement, nextNode);\n    };\n\n    /**\n     * @summary Renders a template or View to DOM nodes with a data context.  Otherwise identical to `Blaze.render`.\n     * @locus Client\n     * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.\n     * @param {Object|Function} data The data context to use, or a function returning a data context.  If a function is provided, it will be reactively re-run.\n     * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n     * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n     * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n     */\n    Blaze.renderWithData = function (content, data, parentElement, nextNode, parentView) {\n      // We defer the handling of optional arguments to Blaze.render.  At this point,\n      // `nextNode` may actually be `parentView`.\n      return Blaze.render(Blaze._TemplateWith(data, contentAsFunc(content)), parentElement, nextNode, parentView);\n    };\n\n    /**\n     * @summary Removes a rendered View from the DOM, stopping all reactive updates and event listeners on it. Also destroys the Blaze.Template instance associated with the view.\n     * @locus Client\n     * @param {Blaze.View} renderedView The return value from `Blaze.render` or `Blaze.renderWithData`, or the `view` property of a Blaze.Template instance. Calling `Blaze.remove(Template.instance().view)` from within a template event handler will destroy the view as well as that template and trigger the template's `onDestroyed` handlers.\n     */\n    Blaze.remove = function (view) {\n      if (!(view && view._domrange instanceof Blaze._DOMRange)) throw new Error(\"Expected template rendered with Blaze.render\");\n      while (view) {\n        if (!view.isDestroyed) {\n          const range = view._domrange;\n          range.destroy();\n          if (range.attached && !range.parentRange) {\n            range.detach();\n          }\n        }\n        view = view._hasGeneratedParent && view.parentView;\n      }\n    };\n\n    /**\n     * @summary Renders a template or View to a string of HTML.\n     * @locus Client\n     * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n     */\n    Blaze.toHTML = function (content, parentView) {\n      parentView = parentView || currentViewIfRendering();\n      return HTML.toHTML(Blaze._expandView(contentAsView(content), parentView));\n    };\n\n    /**\n     * @summary Renders a template or View to HTML with a data context.  Otherwise identical to `Blaze.toHTML`.\n     * @locus Client\n     * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n     * @param {Object|Function} data The data context to use, or a function returning a data context.\n     */\n    Blaze.toHTMLWithData = function (content, data, parentView) {\n      parentView = parentView || currentViewIfRendering();\n      return HTML.toHTML(Blaze._expandView(Blaze._TemplateWith(data, contentAsFunc(content)), parentView));\n    };\n    Blaze._toText = function (htmljs, parentView, textMode) {\n      if (typeof htmljs === 'function') throw new Error(\"Blaze._toText doesn't take a function, just HTMLjs\");\n      if (parentView != null && !(parentView instanceof Blaze.View)) {\n        // omitted parentView argument\n        textMode = parentView;\n        parentView = null;\n      }\n      parentView = parentView || currentViewIfRendering();\n      if (!textMode) throw new Error(\"textMode required\");\n      if (!(textMode === HTML.TEXTMODE.STRING || textMode === HTML.TEXTMODE.RCDATA || textMode === HTML.TEXTMODE.ATTRIBUTE)) throw new Error(\"Unknown textMode: \" + textMode);\n      return HTML.toText(Blaze._expand(htmljs, parentView), textMode);\n    };\n\n    /**\n     * @summary Returns the current data context, or the data context that was used when rendering a particular DOM element or View from a Meteor template.\n     * @locus Client\n     * @param {DOMElement|Blaze.View} [elementOrView] Optional.  An element that was rendered by a Meteor, or a View.\n     */\n    Blaze.getData = function (elementOrView) {\n      var _theWith$dataVar$get;\n      let theWith;\n      if (!elementOrView) {\n        theWith = Blaze.getView('with');\n      } else if (elementOrView instanceof Blaze.View) {\n        const view = elementOrView;\n        theWith = view.name === 'with' ? view : Blaze.getView(view, 'with');\n      } else if (typeof elementOrView.nodeType === 'number') {\n        if (elementOrView.nodeType !== 1) throw new Error(\"Expected DOM element\");\n        theWith = Blaze.getView(elementOrView, 'with');\n      } else {\n        throw new Error(\"Expected DOM element or View\");\n      }\n      return theWith ? (_theWith$dataVar$get = theWith.dataVar.get()) === null || _theWith$dataVar$get === void 0 ? void 0 : _theWith$dataVar$get.value : null;\n    };\n\n    // For back-compat\n    Blaze.getElementData = function (element) {\n      Blaze._warn(\"Blaze.getElementData has been deprecated.  Use \" + \"Blaze.getData(element) instead.\");\n      if (element.nodeType !== 1) throw new Error(\"Expected DOM element\");\n      return Blaze.getData(element);\n    };\n\n    // Both arguments are optional.\n\n    /**\n     * @summary Gets either the current View, or the View enclosing the given DOM element.\n     * @locus Client\n     * @param {DOMElement} [element] Optional.  If specified, the View enclosing `element` is returned.\n     */\n    Blaze.getView = function (elementOrView, _viewName) {\n      let viewName = _viewName;\n      if (typeof elementOrView === 'string') {\n        // omitted elementOrView; viewName present\n        viewName = elementOrView;\n        elementOrView = null;\n      }\n\n      // We could eventually shorten the code by folding the logic\n      // from the other methods into this method.\n      if (!elementOrView) {\n        return Blaze._getCurrentView(viewName);\n      } else if (elementOrView instanceof Blaze.View) {\n        return Blaze._getParentView(elementOrView, viewName);\n      } else if (typeof elementOrView.nodeType === 'number') {\n        return Blaze._getElementView(elementOrView, viewName);\n      } else {\n        throw new Error(\"Expected DOM element or View\");\n      }\n    };\n\n    // Gets the current view or its nearest ancestor of name\n    // `name`.\n    Blaze._getCurrentView = function (name) {\n      let view = Blaze.currentView;\n      // Better to fail in cases where it doesn't make sense\n      // to use Blaze._getCurrentView().  There will be a current\n      // view anywhere it does.  You can check Blaze.currentView\n      // if you want to know whether there is one or not.\n      if (!view) throw new Error(\"There is no current view\");\n      if (name) {\n        while (view && view.name !== name) view = view.parentView;\n        return view || null;\n      } else {\n        // Blaze._getCurrentView() with no arguments just returns\n        // Blaze.currentView.\n        return view;\n      }\n    };\n    Blaze._getParentView = function (view, name) {\n      let v = view.parentView;\n      if (name) {\n        while (v && v.name !== name) v = v.parentView;\n      }\n      return v || null;\n    };\n    Blaze._getElementView = function (elem, name) {\n      let range = Blaze._DOMRange.forElement(elem);\n      let view = null;\n      while (range && !view) {\n        view = range.view || null;\n        if (!view) {\n          if (range.parentRange) range = range.parentRange;else range = Blaze._DOMRange.forElement(range.parentElement);\n        }\n      }\n      if (name) {\n        while (view && view.name !== name) view = view.parentView;\n        return view || null;\n      } else {\n        return view;\n      }\n    };\n    Blaze._addEventMap = function (view, eventMap, thisInHandler) {\n      thisInHandler = thisInHandler || null;\n      const handles = [];\n      if (!view._domrange) throw new Error(\"View must have a DOMRange\");\n      view._domrange.onAttached(function attached_eventMaps(range, element) {\n        Object.keys(eventMap).forEach(function (spec) {\n          let handler = eventMap[spec];\n          const clauses = spec.split(/,\\s+/);\n          // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\n          clauses.forEach(function (clause) {\n            const parts = clause.split(/\\s+/);\n            if (parts.length === 0) return;\n            const newEvents = parts.shift();\n            const selector = parts.join(' ');\n            handles.push(Blaze._EventSupport.listen(element, newEvents, selector, function (evt) {\n              if (!range.containsElement(evt.currentTarget, selector, newEvents)) return null;\n              const handlerThis = thisInHandler || this;\n              const handlerArgs = arguments;\n              return Blaze._withCurrentView(view, function () {\n                return handler.apply(handlerThis, handlerArgs);\n              });\n            }, range, function (r) {\n              return r.parentRange;\n            }));\n          });\n        });\n      });\n      view.onViewDestroyed(function () {\n        handles.forEach(function (h) {\n          h.stop();\n        });\n        handles.length = 0;\n      });\n    };\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"builtins.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/builtins.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let has;\n    module.link(\"lodash.has\", {\n      default(v) {\n        has = v;\n      }\n    }, 0);\n    let isObject;\n    module.link(\"lodash.isobject\", {\n      default(v) {\n        isObject = v;\n      }\n    }, 1);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    Blaze._calculateCondition = function (cond) {\n      if (HTML.isArray(cond) && cond.length === 0) return false;\n      return !!cond;\n    };\n\n    /**\n     * @summary Constructs a View that renders content with a data context.\n     * @locus Client\n     * @param {Object|Function} data An object to use as the data context, or a function returning such an object.  If a\n     *   function is provided, it will be reactively re-run.\n     * @param {Function} contentFunc A Function that returns [*renderable content*](#Renderable-Content).\n     */\n    Blaze.With = function (data, contentFunc) {\n      const view = Blaze.View('with', contentFunc);\n      view.dataVar = null;\n      view.onViewCreated(() => {\n        view.dataVar = _createBinding(view, data, 'setData');\n      });\n      return view;\n    };\n\n    /**\n     * @summary Shallow compare of two bindings.\n     * @param {Binding} x\n     * @param {Binding} y\n     */\n    function _isEqualBinding(x, y) {\n      if (typeof x === 'object' && typeof y === 'object') {\n        return x.error === y.error && ReactiveVar._isEqual(x.value, y.value);\n      } else {\n        return ReactiveVar._isEqual(x, y);\n      }\n    }\n\n    /**\n     * @template T\n     * @param {T} x\n     * @returns {T}\n     */\n    function _identity(x) {\n      return x;\n    }\n\n    /**\n     * Attaches a single binding to the instantiated view.\n     * @template T, U\n     * @param {ReactiveVar<U>} reactiveVar Target view.\n     * @param {Promise<T> | T} value Bound value.\n     * @param {function(T): U} [mapper] Maps the computed value before store.\n     */\n    function _setBindingValue(reactiveVar, value) {\n      let mapper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _identity;\n      if (value && typeof value.then === 'function') {\n        value.then(value => reactiveVar.set({\n          value: mapper(value)\n        }), error => reactiveVar.set({\n          error\n        }));\n      } else {\n        reactiveVar.set({\n          value: mapper(value)\n        });\n      }\n    }\n\n    /**\n     * @template T, U\n     * @param {Blaze.View} view Target view.\n     * @param {Promise<T> | T | function(): (Promise<T> | T)} binding Binding value or its getter.\n     * @param {string} [displayName] Autorun's display name.\n     * @param {function(T): U} [mapper] Maps the computed value before store.\n     * @returns {ReactiveVar<U>}\n     */\n    function _createBinding(view, binding, displayName, mapper) {\n      const reactiveVar = new ReactiveVar(undefined, _isEqualBinding);\n      if (typeof binding === 'function') {\n        view.autorun(() => _setBindingValue(reactiveVar, binding(), mapper), view.parentView, displayName);\n      } else {\n        _setBindingValue(reactiveVar, binding, mapper);\n      }\n      return reactiveVar;\n    }\n\n    /**\n     * Attaches bindings to the instantiated view.\n     * @param {Object} bindings A dictionary of bindings, each binding name\n     * corresponds to a value or a function that will be reactively re-run.\n     * @param {Blaze.View} view The target.\n     */\n    Blaze._attachBindingsToView = function (bindings, view) {\n      view.onViewCreated(function () {\n        Object.entries(bindings).forEach(function (_ref) {\n          let [name, binding] = _ref;\n          view._scopeBindings[name] = _createBinding(view, binding);\n        });\n      });\n    };\n\n    /**\n     * @summary Constructs a View setting the local lexical scope in the block.\n     * @param {Function} bindings Dictionary mapping names of bindings to\n     * values or computations to reactively re-run.\n     * @param {Function} contentFunc A Function that returns [*renderable content*](#Renderable-Content).\n     */\n    Blaze.Let = function (bindings, contentFunc) {\n      var view = Blaze.View('let', contentFunc);\n      Blaze._attachBindingsToView(bindings, view);\n      return view;\n    };\n\n    /**\n     * @summary Constructs a View that renders content conditionally.\n     * @locus Client\n     * @param {Function} conditionFunc A function to reactively re-run.  Whether the result is truthy or falsy determines\n     *   whether `contentFunc` or `elseFunc` is shown.  An empty array is considered falsy.\n     * @param {Function} contentFunc A Function that returns [*renderable content*](#Renderable-Content).\n     * @param {Function} [elseFunc] Optional.  A Function that returns [*renderable content*](#Renderable-Content).  If no\n     *   `elseFunc` is supplied, no content is shown in the \"else\" case.\n     */\n    Blaze.If = function (conditionFunc, contentFunc, elseFunc, _not) {\n      const view = Blaze.View(_not ? 'unless' : 'if', function () {\n        // Render only if the binding has a value, i.e., it's either synchronous or\n        // has resolved. Rejected `Promise`s are NOT rendered.\n        const condition = view.__conditionVar.get();\n        if (condition && 'value' in condition) {\n          return condition.value ? contentFunc() : elseFunc ? elseFunc() : null;\n        }\n        return null;\n      });\n      view.__conditionVar = null;\n      view.onViewCreated(() => {\n        view.__conditionVar = _createBinding(view, conditionFunc, 'condition',\n        // Store only the actual condition.\n        value => !Blaze._calculateCondition(value) !== !_not);\n      });\n      return view;\n    };\n\n    /**\n     * @summary An inverted [`Blaze.If`](#Blaze-If).\n     * @locus Client\n     * @param {Function} conditionFunc A function to reactively re-run.  If the result is falsy, `contentFunc` is shown,\n     *   otherwise `elseFunc` is shown.  An empty array is considered falsy.\n     * @param {Function} contentFunc A Function that returns [*renderable content*](#Renderable-Content).\n     * @param {Function} [elseFunc] Optional.  A Function that returns [*renderable content*](#Renderable-Content).  If no\n     *   `elseFunc` is supplied, no content is shown in the \"else\" case.\n     */\n    Blaze.Unless = function (conditionFunc, contentFunc, elseFunc) {\n      return Blaze.If(conditionFunc, contentFunc, elseFunc, true /*_not*/);\n    };\n\n    /**\n     * @summary Constructs a View that renders `contentFunc` for each item in a sequence.\n     * @locus Client\n     * @param {Function} argFunc A function to reactively re-run. The function can\n     * return one of two options:\n     *\n     * 1. An object with two fields: '_variable' and '_sequence'. Each iterates over\n     *   '_sequence', it may be a Cursor, an array, null, or undefined. Inside the\n     *   Each body you will be able to get the current item from the sequence using\n     *   the name specified in the '_variable' field.\n     *\n     * 2. Just a sequence (Cursor, array, null, or undefined) not wrapped into an\n     *   object. Inside the Each body, the current item will be set as the data\n     *   context.\n     * @param {Function} contentFunc A Function that returns  [*renderable\n     * content*](#Renderable-Content).\n     * @param {Function} [elseFunc] A Function that returns [*renderable\n     * content*](#Renderable-Content) to display in the case when there are no items\n     * in the sequence.\n     */\n    Blaze.Each = function (argFunc, contentFunc, elseFunc) {\n      const eachView = Blaze.View('each', function () {\n        const subviews = this.initialSubviews;\n        this.initialSubviews = null;\n        if (this._isCreatedForExpansion) {\n          this.expandedValueDep = new Tracker.Dependency();\n          this.expandedValueDep.depend();\n        }\n        return subviews;\n      });\n      eachView.initialSubviews = [];\n      eachView.numItems = 0;\n      eachView.inElseMode = false;\n      eachView.stopHandle = null;\n      eachView.contentFunc = contentFunc;\n      eachView.elseFunc = elseFunc;\n      eachView.argVar = undefined;\n      eachView.variableName = null;\n\n      // update the @index value in the scope of all subviews in the range\n      const updateIndices = function (from, to) {\n        if (to === undefined) {\n          to = eachView.numItems - 1;\n        }\n        for (let i = from; i <= to; i++) {\n          const view = eachView._domrange.members[i].view;\n          view._scopeBindings['@index'].set({\n            value: i\n          });\n        }\n      };\n      eachView.onViewCreated(function () {\n        // We evaluate `argFunc` in `Tracker.autorun` to ensure `Blaze.currentView`\n        // is always set when it runs.\n        eachView.argVar = _createBinding(eachView,\n        // Unwrap a sequence reactively (`{{#each x in xs}}`).\n        () => {\n          let maybeSequence = argFunc();\n          if (isObject(maybeSequence) && has(maybeSequence, '_sequence')) {\n            eachView.variableName = maybeSequence._variable || null;\n            maybeSequence = maybeSequence._sequence;\n          }\n          return maybeSequence;\n        }, 'collection');\n        eachView.stopHandle = ObserveSequence.observe(function () {\n          var _eachView$argVar$get;\n          return (_eachView$argVar$get = eachView.argVar.get()) === null || _eachView$argVar$get === void 0 ? void 0 : _eachView$argVar$get.value;\n        }, {\n          addedAt: function (id, item, index) {\n            Tracker.nonreactive(function () {\n              let newItemView;\n              if (eachView.variableName) {\n                // new-style #each (as in {{#each item in items}})\n                // doesn't create a new data context\n                newItemView = Blaze.View('item', eachView.contentFunc);\n              } else {\n                newItemView = Blaze.With(item, eachView.contentFunc);\n              }\n              eachView.numItems++;\n              const bindings = {};\n              bindings['@index'] = index;\n              if (eachView.variableName) {\n                bindings[eachView.variableName] = item;\n              }\n              Blaze._attachBindingsToView(bindings, newItemView);\n              if (eachView.expandedValueDep) {\n                eachView.expandedValueDep.changed();\n              } else if (eachView._domrange) {\n                if (eachView.inElseMode) {\n                  eachView._domrange.removeMember(0);\n                  eachView.inElseMode = false;\n                }\n                const range = Blaze._materializeView(newItemView, eachView);\n                eachView._domrange.addMember(range, index);\n                updateIndices(index);\n              } else {\n                eachView.initialSubviews.splice(index, 0, newItemView);\n              }\n            });\n          },\n          removedAt: function (id, item, index) {\n            Tracker.nonreactive(function () {\n              eachView.numItems--;\n              if (eachView.expandedValueDep) {\n                eachView.expandedValueDep.changed();\n              } else if (eachView._domrange) {\n                eachView._domrange.removeMember(index);\n                updateIndices(index);\n                if (eachView.elseFunc && eachView.numItems === 0) {\n                  eachView.inElseMode = true;\n                  eachView._domrange.addMember(Blaze._materializeView(Blaze.View('each_else', eachView.elseFunc), eachView), 0);\n                }\n              } else {\n                eachView.initialSubviews.splice(index, 1);\n              }\n            });\n          },\n          changedAt: function (id, newItem, oldItem, index) {\n            Tracker.nonreactive(function () {\n              if (eachView.expandedValueDep) {\n                eachView.expandedValueDep.changed();\n              } else {\n                let itemView;\n                if (eachView._domrange) {\n                  itemView = eachView._domrange.getMember(index).view;\n                } else {\n                  itemView = eachView.initialSubviews[index];\n                }\n                if (eachView.variableName) {\n                  itemView._scopeBindings[eachView.variableName].set({\n                    value: newItem\n                  });\n                } else {\n                  itemView.dataVar.set({\n                    value: newItem\n                  });\n                }\n              }\n            });\n          },\n          movedTo: function (id, item, fromIndex, toIndex) {\n            Tracker.nonreactive(function () {\n              if (eachView.expandedValueDep) {\n                eachView.expandedValueDep.changed();\n              } else if (eachView._domrange) {\n                eachView._domrange.moveMember(fromIndex, toIndex);\n                updateIndices(Math.min(fromIndex, toIndex), Math.max(fromIndex, toIndex));\n              } else {\n                const subviews = eachView.initialSubviews;\n                const itemView = subviews[fromIndex];\n                subviews.splice(fromIndex, 1);\n                subviews.splice(toIndex, 0, itemView);\n              }\n            });\n          }\n        });\n        if (eachView.elseFunc && eachView.numItems === 0) {\n          eachView.inElseMode = true;\n          eachView.initialSubviews[0] = Blaze.View('each_else', eachView.elseFunc);\n        }\n      });\n      eachView.onViewDestroyed(function () {\n        if (eachView.stopHandle) eachView.stopHandle.stop();\n      });\n      return eachView;\n    };\n\n    /**\n     * Create a new `Blaze.Let` view that unwraps the given value.\n     * @param {unknown} value\n     * @returns {Blaze.View}\n     */\n    Blaze._Await = function (value) {\n      return Blaze.Let({\n        value\n      }, Blaze._AwaitContent);\n    };\n    Blaze._AwaitContent = function () {\n      var _Blaze$currentView$_s;\n      return (_Blaze$currentView$_s = Blaze.currentView._scopeBindings.value.get()) === null || _Blaze$currentView$_s === void 0 ? void 0 : _Blaze$currentView$_s.value;\n    };\n    Blaze._TemplateWith = function (arg, contentFunc) {\n      let w;\n      let argFunc = arg;\n      if (typeof arg !== 'function') {\n        argFunc = function () {\n          return arg;\n        };\n      }\n\n      // This is a little messy.  When we compile `{{> Template.contentBlock}}`, we\n      // wrap it in Blaze._InOuterTemplateScope in order to skip the intermediate\n      // parent Views in the current template.  However, when there's an argument\n      // (`{{> Template.contentBlock arg}}`), the argument needs to be evaluated\n      // in the original scope.  There's no good order to nest\n      // Blaze._InOuterTemplateScope and Blaze._TemplateWith to achieve this,\n      // so we wrap argFunc to run it in the \"original parentView\" of the\n      // Blaze._InOuterTemplateScope.\n      //\n      // To make this better, reconsider _InOuterTemplateScope as a primitive.\n      // Longer term, evaluate expressions in the proper lexical scope.\n      const wrappedArgFunc = function () {\n        let viewToEvaluateArg = null;\n        if (w.parentView && w.parentView.name === 'InOuterTemplateScope') {\n          viewToEvaluateArg = w.parentView.originalParentView;\n        }\n        if (viewToEvaluateArg) {\n          return Blaze._withCurrentView(viewToEvaluateArg, argFunc);\n        } else {\n          return argFunc();\n        }\n      };\n      const wrappedContentFunc = function () {\n        let content = contentFunc.call(this);\n\n        // Since we are generating the Blaze._TemplateWith view for the\n        // user, set the flag on the child view.  If `content` is a template,\n        // construct the View so that we can set the flag.\n        if (content instanceof Blaze.Template) {\n          content = content.constructView();\n        }\n        if (content instanceof Blaze.View) {\n          content._hasGeneratedParent = true;\n        }\n        return content;\n      };\n      w = Blaze.With(wrappedArgFunc, wrappedContentFunc);\n      w.__isTemplateWith = true;\n      return w;\n    };\n    Blaze._InOuterTemplateScope = function (templateView, contentFunc) {\n      const view = Blaze.View('InOuterTemplateScope', contentFunc);\n      let parentView = templateView.parentView;\n\n      // Hack so that if you call `{{> foo bar}}` and it expands into\n      // `{{#with bar}}{{> foo}}{{/with}}`, and then `foo` is a template\n      // that inserts `{{> Template.contentBlock}}`, the data context for\n      // `Template.contentBlock` is not `bar` but the one enclosing that.\n      if (parentView.__isTemplateWith) parentView = parentView.parentView;\n      view.onViewCreated(function () {\n        this.originalParentView = this.parentView;\n        this.parentView = parentView;\n        this.__childDoesntStartNewLexicalScope = true;\n      });\n      return view;\n    };\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lookup.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/lookup.js                                                                                            //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let has;\n    module.link(\"lodash.has\", {\n      default(v) {\n        has = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    /** @param {function(Binding): boolean} fn */\n    function _createBindingsHelper(fn) {\n      /** @param {string[]} names */\n      return function () {\n        for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {\n          names[_key] = arguments[_key];\n        }\n        const view = Blaze.currentView;\n\n        // There's either zero arguments (i.e., check all bindings) or an additional\n        // \"hash\" argument that we have to ignore.\n        names = names.length === 0\n        // TODO: Should we walk up the bindings here?\n        ? Object.keys(view._scopeBindings) : names.slice(0, -1);\n        return names.some(name => {\n          const binding = _lexicalBindingLookup(view, name);\n          if (!binding) {\n            throw new Error(\"Binding for \\\"\".concat(name, \"\\\" was not found.\"));\n          }\n          return fn(binding.get());\n        });\n      };\n    }\n    Blaze._globalHelpers = {\n      /** @summary Check whether any of the given bindings (or all if none given) is still pending. */\n      '@pending': _createBindingsHelper(binding => binding === undefined),\n      /** @summary Check whether any of the given bindings (or all if none given) has rejected. */\n      '@rejected': _createBindingsHelper(binding => !!binding && 'error' in binding),\n      /** @summary Check whether any of the given bindings (or all if none given) has resolved. */\n      '@resolved': _createBindingsHelper(binding => !!binding && 'value' in binding)\n    };\n\n    // Documented as Template.registerHelper.\n    // This definition also provides back-compat for `UI.registerHelper`.\n    Blaze.registerHelper = function (name, func) {\n      Blaze._globalHelpers[name] = func;\n    };\n\n    // Also documented as Template.deregisterHelper\n    Blaze.deregisterHelper = function (name) {\n      delete Blaze._globalHelpers[name];\n    };\n    const bindIfIsFunction = function (x, target) {\n      if (typeof x !== 'function') return x;\n      return Blaze._bind(x, target);\n    };\n\n    // If `x` is a function, binds the value of `this` for that function\n    // to the current data context.\n    const bindDataContext = function (x) {\n      if (typeof x === 'function') {\n        return function () {\n          let data = Blaze.getData();\n          if (data == null) data = {};\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n          return x.apply(data, args);\n        };\n      }\n      return x;\n    };\n    Blaze._OLDSTYLE_HELPER = {};\n    Blaze._getTemplateHelper = function (template, name, tmplInstanceFunc) {\n      // XXX COMPAT WITH 0.9.3\n      let isKnownOldStyleHelper = false;\n      if (template.__helpers.has(name)) {\n        const helper = template.__helpers.get(name);\n        if (helper === Blaze._OLDSTYLE_HELPER) {\n          isKnownOldStyleHelper = true;\n        } else if (helper != null) {\n          const printName = \"\".concat(template.viewName, \" \").concat(name);\n          return wrapHelper(bindDataContext(helper), tmplInstanceFunc, printName);\n        } else {\n          return null;\n        }\n      }\n\n      // old-style helper\n      if (name in template) {\n        // Only warn once per helper\n        if (!isKnownOldStyleHelper) {\n          template.__helpers.set(name, Blaze._OLDSTYLE_HELPER);\n          if (!template._NOWARN_OLDSTYLE_HELPERS) {\n            Blaze._warn('Assigning helper with `' + template.viewName + '.' + name + ' = ...` is deprecated.  Use `' + template.viewName + '.helpers(...)` instead.');\n          }\n        }\n        if (template[name] != null) {\n          return wrapHelper(bindDataContext(template[name]), tmplInstanceFunc);\n        }\n      }\n      return null;\n    };\n    const wrapHelper = function (f, templateFunc) {\n      let name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'template helper';\n      if (typeof f !== \"function\") {\n        return f;\n      }\n      return function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        const self = this;\n        return Blaze.Template._withTemplateInstanceFunc(templateFunc, function () {\n          return Blaze._wrapCatchingExceptions(f, name).apply(self, args);\n        });\n      };\n    };\n    function _lexicalKeepGoing(currentView) {\n      if (!currentView.parentView) {\n        return undefined;\n      }\n      if (!currentView.__startsNewLexicalScope) {\n        return currentView.parentView;\n      }\n      if (currentView.parentView.__childDoesntStartNewLexicalScope) {\n        return currentView.parentView;\n      }\n\n      // in the case of {{> Template.contentBlock data}} the contentBlock loses the lexical scope of it's parent, wheras {{> Template.contentBlock}} it does not\n      // this is because a #with sits between the include InOuterTemplateScope\n      if (currentView.parentView.name === \"with\" && currentView.parentView.parentView && currentView.parentView.parentView.__childDoesntStartNewLexicalScope) {\n        return currentView.parentView;\n      }\n      return undefined;\n    }\n    function _lexicalBindingLookup(view, name) {\n      let currentView = view;\n\n      // walk up the views stopping at a Spacebars.include or Template view that\n      // doesn't have an InOuterTemplateScope view as a parent\n      do {\n        // skip block helpers views\n        // if we found the binding on the scope, return it\n        if (has(currentView._scopeBindings, name)) {\n          return currentView._scopeBindings[name];\n        }\n      } while (currentView = _lexicalKeepGoing(currentView));\n      return null;\n    }\n    Blaze._lexicalBindingLookup = function (view, name) {\n      const binding = _lexicalBindingLookup(view, name);\n      return binding && (() => {\n        var _binding$get;\n        return (_binding$get = binding.get()) === null || _binding$get === void 0 ? void 0 : _binding$get.value;\n      });\n    };\n\n    // templateInstance argument is provided to be available for possible\n    // alternative implementations of this function by 3rd party packages.\n    Blaze._getTemplate = function (name, templateInstance) {\n      if (name in Blaze.Template && Blaze.Template[name] instanceof Blaze.Template) {\n        return Blaze.Template[name];\n      }\n      return null;\n    };\n    Blaze._getGlobalHelper = function (name, templateInstance) {\n      if (Blaze._globalHelpers[name] != null) {\n        const printName = \"global helper \".concat(name);\n        return wrapHelper(bindDataContext(Blaze._globalHelpers[name]), templateInstance, printName);\n      }\n      return null;\n    };\n\n    // Looks up a name, like \"foo\" or \"..\", as a helper of the\n    // current template; the name of a template; a global helper;\n    // or a property of the data context.  Called on the View of\n    // a template (i.e. a View with a `.template` property,\n    // where the helpers are).  Used for the first name in a\n    // \"path\" in a template tag, like \"foo\" in `{{foo.bar}}` or\n    // \"..\" in `{{frobulate ../blah}}`.\n    //\n    // Returns a function, a non-function value, or null.  If\n    // a function is found, it is bound appropriately.\n    //\n    // NOTE: This function must not establish any reactive\n    // dependencies itself.  If there is any reactivity in the\n    // value, lookup should return a function.\n    Blaze.View.prototype.lookup = function (name, _options) {\n      const template = this.template;\n      const lookupTemplate = _options && _options.template;\n      let helper;\n      let binding;\n      let boundTmplInstance;\n      let foundTemplate;\n      if (this.templateInstance) {\n        boundTmplInstance = Blaze._bind(this.templateInstance, this);\n      }\n\n      // 0. looking up the parent data context with the special \"../\" syntax\n      if (/^\\./.test(name)) {\n        // starts with a dot. must be a series of dots which maps to an\n        // ancestor of the appropriate height.\n        if (!/^(\\.)+$/.test(name)) throw new Error(\"id starting with dot must be a series of dots\");\n        return Blaze._parentData(name.length - 1, true /*_functionWrapped*/);\n      }\n\n      // 1. look up a helper on the current template\n      if (template && (helper = Blaze._getTemplateHelper(template, name, boundTmplInstance)) != null) {\n        return helper;\n      }\n\n      // 2. look up a binding by traversing the lexical view hierarchy inside the\n      // current template\n      if (template && (binding = Blaze._lexicalBindingLookup(Blaze.currentView, name)) != null) {\n        return binding;\n      }\n\n      // 3. look up a template by name\n      if (lookupTemplate && (foundTemplate = Blaze._getTemplate(name, boundTmplInstance)) != null) {\n        return foundTemplate;\n      }\n\n      // 4. look up a global helper\n      helper = Blaze._getGlobalHelper(name, boundTmplInstance);\n      if (helper != null) {\n        return helper;\n      }\n\n      // 5. look up in a data context\n      return function () {\n        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n        const isCalledAsFunction = args.length > 0;\n        const data = Blaze.getData();\n        const x = data && data[name];\n        if (!x) {\n          if (lookupTemplate) {\n            throw new Error(\"No such template: \" + name);\n          } else if (isCalledAsFunction) {\n            throw new Error(\"No such function: \" + name);\n          } else if (name.charAt(0) === '@' && (x === null || x === undefined)) {\n            // Throw an error if the user tries to use a `@directive`\n            // that doesn't exist.  We don't implement all directives\n            // from Handlebars, so there's a potential for confusion\n            // if we fail silently.  On the other hand, we want to\n            // throw late in case some app or package wants to provide\n            // a missing directive.\n            throw new Error(\"Unsupported directive: \" + name);\n          }\n        }\n        if (!data) {\n          return null;\n        }\n        if (typeof x !== 'function') {\n          if (isCalledAsFunction) {\n            throw new Error(\"Can't call non-function: \" + x);\n          }\n          return x;\n        }\n        return x.apply(data, args);\n      };\n    };\n\n    // Implement Spacebars' {{../..}}.\n    // @param height {Number} The number of '..'s\n    Blaze._parentData = function (height, _functionWrapped) {\n      var _theWith$dataVar$get2;\n      // If height is null or undefined, we default to 1, the first parent.\n      if (height == null) {\n        height = 1;\n      }\n      let theWith = Blaze.getView('with');\n      for (let i = 0; i < height && theWith; i++) {\n        theWith = Blaze.getView(theWith, 'with');\n      }\n      if (!theWith) return null;\n      if (_functionWrapped) return function () {\n        var _theWith$dataVar$get;\n        return (_theWith$dataVar$get = theWith.dataVar.get()) === null || _theWith$dataVar$get === void 0 ? void 0 : _theWith$dataVar$get.value;\n      };\n      return (_theWith$dataVar$get2 = theWith.dataVar.get()) === null || _theWith$dataVar$get2 === void 0 ? void 0 : _theWith$dataVar$get2.value;\n    };\n    Blaze.View.prototype.lookupTemplate = function (name) {\n      return this.lookup(name, {\n        template: true\n      });\n    };\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"template.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/template.js                                                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let isObject;\n    module.link(\"lodash.isobject\", {\n      default(v) {\n        isObject = v;\n      }\n    }, 0);\n    let isFunction;\n    module.link(\"lodash.isfunction\", {\n      default(v) {\n        isFunction = v;\n      }\n    }, 1);\n    let has;\n    module.link(\"lodash.has\", {\n      default(v) {\n        has = v;\n      }\n    }, 2);\n    let isEmpty;\n    module.link(\"lodash.isempty\", {\n      default(v) {\n        isEmpty = v;\n      }\n    }, 3);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    // [new] Blaze.Template([viewName], renderFunction)\n    //\n    // `Blaze.Template` is the class of templates, like `Template.foo` in\n    // Meteor, which is `instanceof Template`.\n    //\n    // `viewKind` is a string that looks like \"Template.foo\" for templates\n    // defined by the compiler.\n\n    /**\n     * @class\n     * @summary Constructor for a Template, which is used to construct Views with particular name and content.\n     * @locus Client\n     * @param {String} [viewName] Optional.  A name for Views constructed by this Template.  See [`view.name`](#view_name).\n     * @param {Function} renderFunction A function that returns [*renderable content*](#Renderable-Content).  This function is used as the `renderFunction` for Views constructed by this Template.\n     */\n    Blaze.Template = function (viewName, renderFunction) {\n      if (!(this instanceof Blaze.Template))\n        // called without `new`\n        return new Blaze.Template(viewName, renderFunction);\n      if (typeof viewName === 'function') {\n        // omitted \"viewName\" argument\n        renderFunction = viewName;\n        viewName = '';\n      }\n      if (typeof viewName !== 'string') throw new Error(\"viewName must be a String (or omitted)\");\n      if (typeof renderFunction !== 'function') throw new Error(\"renderFunction must be a function\");\n      this.viewName = viewName;\n      this.renderFunction = renderFunction;\n      this.__helpers = new HelperMap();\n      this.__eventMaps = [];\n      this._callbacks = {\n        created: [],\n        rendered: [],\n        destroyed: []\n      };\n    };\n    const Template = Blaze.Template;\n    const HelperMap = function () {};\n    HelperMap.prototype.get = function (name) {\n      return this[' ' + name];\n    };\n    HelperMap.prototype.set = function (name, helper) {\n      this[' ' + name] = helper;\n    };\n    HelperMap.prototype.has = function (name) {\n      return typeof this[' ' + name] !== 'undefined';\n    };\n\n    /**\n     * @summary Returns true if `value` is a template object like `Template.myTemplate`.\n     * @locus Client\n     * @param {Any} value The value to test.\n     */\n    Blaze.isTemplate = function (t) {\n      return t instanceof Blaze.Template;\n    };\n\n    /**\n     * @name  onCreated\n     * @instance\n     * @memberOf Template\n     * @summary Register a function to be called when an instance of this template is created.\n     * @param {Function} callback A function to be added as a callback.\n     * @locus Client\n     * @importFromPackage templating\n     */\n    Template.prototype.onCreated = function (cb) {\n      this._callbacks.created.push(cb);\n    };\n\n    /**\n     * @name  onRendered\n     * @instance\n     * @memberOf Template\n     * @summary Register a function to be called when an instance of this template is inserted into the DOM.\n     * @param {Function} callback A function to be added as a callback.\n     * @locus Client\n     * @importFromPackage templating\n     */\n    Template.prototype.onRendered = function (cb) {\n      this._callbacks.rendered.push(cb);\n    };\n\n    /**\n     * @name  onDestroyed\n     * @instance\n     * @memberOf Template\n     * @summary Register a function to be called when an instance of this template is removed from the DOM and destroyed.\n     * @param {Function} callback A function to be added as a callback.\n     * @locus Client\n     * @importFromPackage templating\n     */\n    Template.prototype.onDestroyed = function (cb) {\n      this._callbacks.destroyed.push(cb);\n    };\n    Template.prototype._getCallbacks = function (which) {\n      const self = this;\n      let callbacks = self[which] ? [self[which]] : [];\n      // Fire all callbacks added with the new API (Template.onRendered())\n      // as well as the old-style callback (e.g. Template.rendered) for\n      // backwards-compatibility.\n      callbacks = callbacks.concat(self._callbacks[which]);\n      return callbacks;\n    };\n    const fireCallbacks = function (callbacks, template) {\n      Template._withTemplateInstanceFunc(function () {\n        return template;\n      }, function () {\n        for (let i = 0, N = callbacks.length; i < N; i++) {\n          callbacks[i].call(template);\n        }\n      });\n    };\n    Template.prototype.constructView = function (contentFunc, elseFunc) {\n      const self = this;\n      const view = Blaze.View(self.viewName, self.renderFunction);\n      view.template = self;\n      view.templateContentBlock = contentFunc ? new Template('(contentBlock)', contentFunc) : null;\n      view.templateElseBlock = elseFunc ? new Template('(elseBlock)', elseFunc) : null;\n      if (self.__eventMaps || typeof self.events === 'object') {\n        view._onViewRendered(function () {\n          if (view.renderCount !== 1) return;\n          if (!self.__eventMaps.length && typeof self.events === \"object\") {\n            // Provide limited back-compat support for `.events = {...}`\n            // syntax.  Pass `template.events` to the original `.events(...)`\n            // function.  This code must run only once per template, in\n            // order to not bind the handlers more than once, which is\n            // ensured by the fact that we only do this when `__eventMaps`\n            // is falsy, and we cause it to be set now.\n            Template.prototype.events.call(self, self.events);\n          }\n          self.__eventMaps.forEach(function (m) {\n            Blaze._addEventMap(view, m, view);\n          });\n        });\n      }\n      view._templateInstance = new Blaze.TemplateInstance(view);\n      view.templateInstance = function () {\n        // Update data, firstNode, and lastNode, and return the TemplateInstance\n        // object.\n        const inst = view._templateInstance;\n\n        /**\n         * @instance\n         * @memberOf Blaze.TemplateInstance\n         * @name  data\n         * @summary The data context of this instance's latest invocation.\n         * @locus Client\n         */\n        inst.data = Blaze.getData(view);\n        if (view._domrange && !view.isDestroyed) {\n          inst.firstNode = view._domrange.firstNode();\n          inst.lastNode = view._domrange.lastNode();\n        } else {\n          // on 'created' or 'destroyed' callbacks we don't have a DomRange\n          inst.firstNode = null;\n          inst.lastNode = null;\n        }\n        return inst;\n      };\n\n      /**\n       * @name  created\n       * @instance\n       * @memberOf Template\n       * @summary Provide a callback when an instance of a template is created.\n       * @locus Client\n       * @deprecated in 1.1\n       */\n      // To avoid situations when new callbacks are added in between view\n      // instantiation and event being fired, decide on all callbacks to fire\n      // immediately and then fire them on the event.\n      const createdCallbacks = self._getCallbacks('created');\n      view.onViewCreated(function () {\n        fireCallbacks(createdCallbacks, view.templateInstance());\n      });\n\n      /**\n       * @name  rendered\n       * @instance\n       * @memberOf Template\n       * @summary Provide a callback when an instance of a template is rendered.\n       * @locus Client\n       * @deprecated in 1.1\n       */\n      const renderedCallbacks = self._getCallbacks('rendered');\n      view.onViewReady(function () {\n        fireCallbacks(renderedCallbacks, view.templateInstance());\n      });\n\n      /**\n       * @name  destroyed\n       * @instance\n       * @memberOf Template\n       * @summary Provide a callback when an instance of a template is destroyed.\n       * @locus Client\n       * @deprecated in 1.1\n       */\n      const destroyedCallbacks = self._getCallbacks('destroyed');\n      view.onViewDestroyed(function () {\n        fireCallbacks(destroyedCallbacks, view.templateInstance());\n      });\n      return view;\n    };\n\n    /**\n     * @class\n     * @summary The class for template instances\n     * @param {Blaze.View} view\n     * @instanceName template\n     */\n    Blaze.TemplateInstance = function (view) {\n      if (!(this instanceof Blaze.TemplateInstance))\n        // called without `new`\n        return new Blaze.TemplateInstance(view);\n      if (!(view instanceof Blaze.View)) throw new Error(\"View required\");\n      view._templateInstance = this;\n\n      /**\n       * @name view\n       * @memberOf Blaze.TemplateInstance\n       * @instance\n       * @summary The [View](../api/blaze.html#Blaze-View) object for this invocation of the template.\n       * @locus Client\n       * @type {Blaze.View}\n       */\n      this.view = view;\n      this.data = null;\n\n      /**\n       * @name firstNode\n       * @memberOf Blaze.TemplateInstance\n       * @instance\n       * @summary The first top-level DOM node in this template instance.\n       * @locus Client\n       * @type {DOMNode}\n       */\n      this.firstNode = null;\n\n      /**\n       * @name lastNode\n       * @memberOf Blaze.TemplateInstance\n       * @instance\n       * @summary The last top-level DOM node in this template instance.\n       * @locus Client\n       * @type {DOMNode}\n       */\n      this.lastNode = null;\n\n      // This dependency is used to identify state transitions in\n      // _subscriptionHandles which could cause the result of\n      // TemplateInstance#subscriptionsReady to change. Basically this is triggered\n      // whenever a new subscription handle is added or when a subscription handle\n      // is removed and they are not ready.\n      this._allSubsReadyDep = new Tracker.Dependency();\n      this._allSubsReady = false;\n      this._subscriptionHandles = {};\n    };\n\n    /**\n     * @summary Find all elements matching `selector` in this template instance, and return them as a JQuery object.\n     * @locus Client\n     * @param {String} selector The CSS selector to match, scoped to the template contents.\n     * @returns {DOMNode[]}\n     */\n    Blaze.TemplateInstance.prototype.$ = function (selector) {\n      const view = this.view;\n      if (!view._domrange) throw new Error(\"Can't use $ on template instance with no DOM\");\n      return view._domrange.$(selector);\n    };\n\n    /**\n     * @summary Find all elements matching `selector` in this template instance.\n     * @locus Client\n     * @param {String} selector The CSS selector to match, scoped to the template contents.\n     * @returns {DOMElement[]}\n     */\n    Blaze.TemplateInstance.prototype.findAll = function (selector) {\n      return Array.prototype.slice.call(this.$(selector));\n    };\n\n    /**\n     * @summary Find one element matching `selector` in this template instance.\n     * @locus Client\n     * @param {String} selector The CSS selector to match, scoped to the template contents.\n     * @returns {DOMElement}\n     */\n    Blaze.TemplateInstance.prototype.find = function (selector) {\n      const result = this.$(selector);\n      return result[0] || null;\n    };\n\n    /**\n     * @summary A version of [Tracker.autorun](https://docs.meteor.com/api/tracker.html#Tracker-autorun) that is stopped when the template is destroyed.\n     * @locus Client\n     * @param {Function} runFunc The function to run. It receives one argument: a Tracker.Computation object.\n     */\n    Blaze.TemplateInstance.prototype.autorun = function (f) {\n      return this.view.autorun(f);\n    };\n\n    /**\n     * @summary A version of [Meteor.subscribe](https://docs.meteor.com/api/pubsub.html#Meteor-subscribe) that is stopped\n     * when the template is destroyed.\n     * @return {SubscriptionHandle} The subscription handle to the newly made\n     * subscription. Call `handle.stop()` to manually stop the subscription, or\n     * `handle.ready()` to find out if this particular subscription has loaded all\n     * of its inital data.\n     * @locus Client\n     * @param {String} name Name of the subscription.  Matches the name of the\n     * server's `publish()` call.\n     * @param {Any} [arg1,arg2...] Optional arguments passed to publisher function\n     * on server.\n     * @param {Function|Object} [options] If a function is passed instead of an\n     * object, it is interpreted as an `onReady` callback.\n     * @param {Function} [options.onReady] Passed to [`Meteor.subscribe`](https://docs.meteor.com/api/pubsub.html#Meteor-subscribe).\n     * @param {Function} [options.onStop] Passed to [`Meteor.subscribe`](https://docs.meteor.com/api/pubsub.html#Meteor-subscribe).\n     * @param {DDP.Connection} [options.connection] The connection on which to make the\n     * subscription.\n     */\n    Blaze.TemplateInstance.prototype.subscribe = function () {\n      const self = this;\n      const subHandles = self._subscriptionHandles;\n\n      // Duplicate logic from Meteor.subscribe\n      let options = {};\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      if (args.length) {\n        const lastParam = args[args.length - 1];\n\n        // Match pattern to check if the last arg is an options argument\n        const lastParamOptionsPattern = {\n          onReady: Match.Optional(Function),\n          // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\n          // onStop with an error callback instead.\n          onError: Match.Optional(Function),\n          onStop: Match.Optional(Function),\n          connection: Match.Optional(Match.Any)\n        };\n        if (isFunction(lastParam)) {\n          options.onReady = args.pop();\n        } else if (lastParam && !isEmpty(lastParam) && Match.test(lastParam, lastParamOptionsPattern)) {\n          options = args.pop();\n        }\n      }\n      let subHandle;\n      const oldStopped = options.onStop;\n      options.onStop = function (error) {\n        // When the subscription is stopped, remove it from the set of tracked\n        // subscriptions to avoid this list growing without bound\n        delete subHandles[subHandle.subscriptionId];\n\n        // Removing a subscription can only change the result of subscriptionsReady\n        // if we are not ready (that subscription could be the one blocking us being\n        // ready).\n        if (!self._allSubsReady) {\n          self._allSubsReadyDep.changed();\n        }\n        if (oldStopped) {\n          oldStopped(error);\n        }\n      };\n      const {\n        onReady,\n        onError,\n        onStop,\n        connection\n      } = options;\n      const callbacks = {\n        onReady,\n        onError,\n        onStop\n      };\n\n      // The callbacks are passed as the last item in the arguments array passed to\n      // View#subscribe\n      args.push(callbacks);\n\n      // View#subscribe takes the connection as one of the options in the last\n      // argument\n      subHandle = self.view.subscribe.call(self.view, args, {\n        connection: connection\n      });\n      if (!has(subHandles, subHandle.subscriptionId)) {\n        subHandles[subHandle.subscriptionId] = subHandle;\n\n        // Adding a new subscription will always cause us to transition from ready\n        // to not ready, but if we are already not ready then this can't make us\n        // ready.\n        if (self._allSubsReady) {\n          self._allSubsReadyDep.changed();\n        }\n      }\n      return subHandle;\n    };\n\n    /**\n     * @summary A reactive function that returns true when all of the subscriptions\n     * called with [this.subscribe](#TemplateInstance-subscribe) are ready.\n     * @return {Boolean} True if all subscriptions on this template instance are\n     * ready.\n     */\n    Blaze.TemplateInstance.prototype.subscriptionsReady = function () {\n      this._allSubsReadyDep.depend();\n      this._allSubsReady = Object.values(this._subscriptionHandles).every(handle => {\n        return handle.ready();\n      });\n      return this._allSubsReady;\n    };\n\n    /**\n     * @summary Specify template helpers available to this template.\n     * @locus Client\n     * @param {Object} helpers Dictionary of helper functions by name.\n     * @importFromPackage templating\n     */\n    Template.prototype.helpers = function (dict) {\n      if (!isObject(dict)) {\n        throw new Error(\"Helpers dictionary has to be an object\");\n      }\n      for (let k in dict) this.__helpers.set(k, dict[k]);\n    };\n    const canUseGetters = function () {\n      if (Object.defineProperty) {\n        let obj = {};\n        try {\n          Object.defineProperty(obj, \"self\", {\n            get: function () {\n              return obj;\n            }\n          });\n        } catch (e) {\n          return false;\n        }\n        return obj.self === obj;\n      }\n      return false;\n    }();\n    if (canUseGetters) {\n      // Like Blaze.currentView but for the template instance. A function\n      // rather than a value so that not all helpers are implicitly dependent\n      // on the current template instance's `data` property, which would make\n      // them dependent on the data context of the template inclusion.\n      let currentTemplateInstanceFunc = null;\n\n      // If getters are supported, define this property with a getter function\n      // to make it effectively read-only, and to work around this bizarre JSC\n      // bug: https://github.com/meteor/meteor/issues/9926\n      Object.defineProperty(Template, \"_currentTemplateInstanceFunc\", {\n        get: function () {\n          return currentTemplateInstanceFunc;\n        }\n      });\n      Template._withTemplateInstanceFunc = function (templateInstanceFunc, func) {\n        if (typeof func !== 'function') {\n          throw new Error(\"Expected function, got: \" + func);\n        }\n        const oldTmplInstanceFunc = currentTemplateInstanceFunc;\n        try {\n          currentTemplateInstanceFunc = templateInstanceFunc;\n          return func();\n        } finally {\n          currentTemplateInstanceFunc = oldTmplInstanceFunc;\n        }\n      };\n    } else {\n      // If getters are not supported, just use a normal property.\n      Template._currentTemplateInstanceFunc = null;\n      Template._withTemplateInstanceFunc = function (templateInstanceFunc, func) {\n        if (typeof func !== 'function') {\n          throw new Error(\"Expected function, got: \" + func);\n        }\n        const oldTmplInstanceFunc = Template._currentTemplateInstanceFunc;\n        try {\n          Template._currentTemplateInstanceFunc = templateInstanceFunc;\n          return func();\n        } finally {\n          Template._currentTemplateInstanceFunc = oldTmplInstanceFunc;\n        }\n      };\n    }\n\n    /**\n     * @summary Specify event handlers for this template.\n     * @locus Client\n     * @param {EventMap} eventMap Event handlers to associate with this template.\n     * @importFromPackage templating\n     */\n    Template.prototype.events = function (eventMap) {\n      if (!isObject(eventMap)) {\n        throw new Error(\"Event map has to be an object\");\n      }\n      const template = this;\n      let eventMap2 = {};\n      for (let k in eventMap) {\n        eventMap2[k] = function (k, v) {\n          return function (event /*, ...*/) {\n            const view = this; // passed by EventAugmenter\n            const args = Array.prototype.slice.call(arguments);\n            // Exiting the current computation to avoid creating unnecessary\n            // and unexpected reactive dependencies with Templates data\n            // or any other reactive dependencies defined in event handlers\n            return Tracker.nonreactive(function () {\n              let data = Blaze.getData(event.currentTarget);\n              if (data == null) data = {};\n              const tmplInstanceFunc = Blaze._bind(view.templateInstance, view);\n              args.splice(1, 0, tmplInstanceFunc());\n              return Template._withTemplateInstanceFunc(tmplInstanceFunc, function () {\n                return v.apply(data, args);\n              });\n            });\n          };\n        }(k, eventMap[k]);\n      }\n      template.__eventMaps.push(eventMap2);\n    };\n\n    /**\n     * @function\n     * @name instance\n     * @memberOf Template\n     * @summary The [template instance](#Template-instances) corresponding to the current template helper, event handler, callback, or autorun.  If there isn't one, `null`.\n     * @locus Client\n     * @returns {Blaze.TemplateInstance}\n     * @importFromPackage templating\n     */\n    Template.instance = function () {\n      return Template._currentTemplateInstanceFunc && Template._currentTemplateInstanceFunc();\n    };\n\n    // Note: Template.currentData() is documented to take zero arguments,\n    // while Blaze.getData takes up to one.\n\n    /**\n     * @summary\n     *\n     * - Inside an `onCreated`, `onRendered`, or `onDestroyed` callback, returns\n     * the data context of the template.\n     * - Inside an event handler, returns the data context of the template on which\n     * this event handler was defined.\n     * - Inside a helper, returns the data context of the DOM node where the helper\n     * was used.\n     *\n     * Establishes a reactive dependency on the result.\n     * @locus Client\n     * @function\n     * @importFromPackage templating\n     */\n    Template.currentData = Blaze.getData;\n\n    /**\n     * @summary Accesses other data contexts that enclose the current data context.\n     * @locus Client\n     * @function\n     * @param {Integer} [numLevels] The number of levels beyond the current data context to look. Defaults to 1.\n     * @importFromPackage templating\n     */\n    Template.parentData = Blaze._parentData;\n\n    /**\n     * @summary Defines a [helper function](#Template-helpers) which can be used from all templates.\n     * @locus Client\n     * @function\n     * @param {String} name The name of the helper function you are defining.\n     * @param {Function} function The helper function itself.\n     * @importFromPackage templating\n     */\n    Template.registerHelper = Blaze.registerHelper;\n\n    /**\n     * @summary Removes a global [helper function](#Template-helpers).\n     * @locus Client\n     * @function\n     * @param {String} name The name of the helper function you are defining.\n     * @importFromPackage templating\n     */\n    Template.deregisterHelper = Blaze.deregisterHelper;\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"backcompat.js\":function module(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/blaze/backcompat.js                                                                                        //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nUI = Blaze;\nBlaze.ReactiveVar = ReactiveVar;\nUI._templateInstance = Blaze.Template.instance;\nHandlebars = {};\nHandlebars.registerHelper = Blaze.registerHelper;\nHandlebars._escape = Blaze._escape;\n\n// Return these from {{...}} helpers to achieve the same as returning\n// strings from {{{...}}} helpers\nHandlebars.SafeString = function (string) {\n  this.string = string;\n};\nHandlebars.SafeString.prototype.toString = function () {\n  return this.string.toString();\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"node_modules\":{\"lodash.has\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor/blaze/node_modules/lodash.has/package.json                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"name\": \"lodash.has\",\n  \"version\": \"4.5.2\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor/blaze/node_modules/lodash.has/index.js                                                          //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.useNode();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"lodash.isobject\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor/blaze/node_modules/lodash.isobject/package.json                                                 //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"name\": \"lodash.isobject\",\n  \"version\": \"3.0.2\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor/blaze/node_modules/lodash.isobject/index.js                                                     //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.useNode();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"lodash.isfunction\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor/blaze/node_modules/lodash.isfunction/package.json                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"name\": \"lodash.isfunction\",\n  \"version\": \"3.0.9\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor/blaze/node_modules/lodash.isfunction/index.js                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.useNode();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"lodash.isempty\":{\"package.json\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor/blaze/node_modules/lodash.isempty/package.json                                                  //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.exports = {\n  \"name\": \"lodash.isempty\",\n  \"version\": \"4.4.0\"\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// node_modules/meteor/blaze/node_modules/lodash.isempty/index.js                                                      //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\nmodule.useNode();\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\n\n/* Exports */\nreturn {\n  export: function () { return {\n      Blaze: Blaze,\n      UI: UI,\n      Handlebars: Handlebars\n    };},\n  require: require,\n  eagerModulePaths: [\n    \"/node_modules/meteor/blaze/preamble.js\",\n    \"/node_modules/meteor/blaze/exceptions.js\",\n    \"/node_modules/meteor/blaze/view.js\",\n    \"/node_modules/meteor/blaze/builtins.js\",\n    \"/node_modules/meteor/blaze/lookup.js\",\n    \"/node_modules/meteor/blaze/template.js\",\n    \"/node_modules/meteor/blaze/backcompat.js\"\n  ]\n}});\n","servePath":"/packages/blaze.js","sourceMap":{"version":3,"sources":["packages/blaze/preamble.js","packages/blaze/exceptions.js","packages/blaze/view.js","packages/blaze/builtins.js","packages/blaze/lookup.js","packages/blaze/template.js","packages/blaze/backcompat.js"],"names":["Blaze","_escape","escape_map","escape_one","c","x","replace","_warn","msg","console","warn","nativeBind","Function","prototype","bind","_bind","func","obj","_len","arguments","length","rest","Array","_key","call","args","apply","objA","objB","debugFunc","_throwNextException","_reportException","e","Meteor","_debug","log","stack","message","_reportExceptionAndThrow","error","_wrapCatchingExceptions","f","where","HTML","module","link","v","__reifyWaitForDeps__","View","name","render","_render","_callbacks","created","rendered","destroyed","isCreated","_isCreatedForExpansion","isRendered","_isAttached","isDestroyed","_isInRender","parentView","_domrange","_hasGeneratedParent","_scopeBindings","renderCount","onViewCreated","cb","push","_onViewRendered","onViewReady","self","fire","Tracker","afterFlush","_withCurrentView","onViewRendered","attached","onAttached","onViewDestroyed","removeViewDestroyedListener","index","lastIndexOf","autorun","_inViewScope","displayName","Error","templateInstanceFunc","Template","_currentTemplateInstanceFunc","viewAutorun","_withTemplateInstanceFunc","comp","stopComputation","stop","onStop","_errorIfShouldntCallSubscribe","subscribe","options","subHandle","connection","firstNode","lastNode","_fireCallbacks","view","which","nonreactive","fireCallbacks","cbs","i","N","_createView","forExpansion","doFirstRender","initialContent","domrange","_DOMRange","teardownHook","range","element","_DOMBackend","Teardown","onElementTeardown","teardown","_destroyView","_materializeView","_workStack","_intoArray","lastHtmljs","doRender","htmljs","firstRun","_isContentEqual","doMaterialize","rangesAndNodes","_materializeDOM","setMembers","onInvalidate","destroyMembers","undefined","initialContents","_expandView","result","_expand","active","_HTMLJSExpander","TransformingVisitor","extend","def","visitObject","constructView","visitAttributes","attrs","visitAttribute","value","tag","currentViewIfRendering","currentView","visit","_expandAttributes","expanded","_skipNodes","_destroyNode","node","nodeType","tearDownElement","a","b","Raw","oldView","checkRenderContent","content","Visitor","contentAsView","contentAsFunc","__rootViews","parentElement","nextNode","indexOf","splice","attach","insert","renderWithData","data","_TemplateWith","remove","destroy","parentRange","detach","toHTML","toHTMLWithData","_toText","textMode","TEXTMODE","STRING","RCDATA","ATTRIBUTE","toText","getData","elementOrView","_theWith$dataVar$get","theWith","getView","dataVar","get","getElementData","_viewName","viewName","_getCurrentView","_getParentView","_getElementView","elem","forElement","_addEventMap","eventMap","thisInHandler","handles","attached_eventMaps","Object","keys","forEach","spec","handler","clauses","split","clause","parts","newEvents","shift","selector","join","_EventSupport","listen","evt","containsElement","currentTarget","handlerThis","handlerArgs","r","h","__reify_async_result__","_reifyError","async","has","default","isObject","_calculateCondition","cond","isArray","With","contentFunc","_createBinding","_isEqualBinding","y","ReactiveVar","_isEqual","_identity","_setBindingValue","reactiveVar","mapper","then","set","binding","_attachBindingsToView","bindings","entries","_ref","Let","If","conditionFunc","elseFunc","_not","condition","__conditionVar","Unless","Each","argFunc","eachView","subviews","initialSubviews","expandedValueDep","Dependency","depend","numItems","inElseMode","stopHandle","argVar","variableName","updateIndices","from","to","members","maybeSequence","_variable","_sequence","ObserveSequence","observe","_eachView$argVar$get","addedAt","id","item","newItemView","changed","removeMember","addMember","removedAt","changedAt","newItem","oldItem","itemView","getMember","movedTo","fromIndex","toIndex","moveMember","Math","min","max","_Await","_AwaitContent","_Blaze$currentView$_s","arg","w","wrappedArgFunc","viewToEvaluateArg","originalParentView","wrappedContentFunc","__isTemplateWith","_InOuterTemplateScope","templateView","__childDoesntStartNewLexicalScope","_createBindingsHelper","fn","names","slice","some","_lexicalBindingLookup","concat","_globalHelpers","registerHelper","deregisterHelper","bindIfIsFunction","target","bindDataContext","_len2","_key2","_OLDSTYLE_HELPER","_getTemplateHelper","template","tmplInstanceFunc","isKnownOldStyleHelper","__helpers","helper","printName","wrapHelper","_NOWARN_OLDSTYLE_HELPERS","templateFunc","_len3","_key3","_lexicalKeepGoing","__startsNewLexicalScope","_binding$get","_getTemplate","templateInstance","_getGlobalHelper","lookup","_options","lookupTemplate","boundTmplInstance","foundTemplate","test","_parentData","_len4","_key4","isCalledAsFunction","charAt","height","_functionWrapped","_theWith$dataVar$get2","isFunction","isEmpty","renderFunction","HelperMap","__eventMaps","isTemplate","t","onCreated","onRendered","onDestroyed","_getCallbacks","callbacks","templateContentBlock","templateElseBlock","events","m","_templateInstance","TemplateInstance","inst","createdCallbacks","renderedCallbacks","destroyedCallbacks","_allSubsReadyDep","_allSubsReady","_subscriptionHandles","$","findAll","find","subHandles","lastParam","lastParamOptionsPattern","onReady","Match","Optional","onError","Any","pop","oldStopped","subscriptionId","subscriptionsReady","values","every","handle","ready","helpers","dict","k","canUseGetters","defineProperty","currentTemplateInstanceFunc","oldTmplInstanceFunc","eventMap2","event","instance","currentData","parentData","UI","Handlebars","SafeString","string","toString"],"mappings":"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","file":"/packages/blaze.js","sourcesContent":["/**\n * @namespace Blaze\n * @summary The namespace for all Blaze-related methods and classes.\n */\nBlaze = {};\n\n// Utility to HTML-escape a string.  Included for legacy reasons.\n// TODO: Should be replaced with _.escape once underscore is upgraded to a newer\n//       version which escapes ` (backtick) as well. Underscore 1.5.2 does not.\nBlaze._escape = (function() {\n  const escape_map = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"/\": \"&#x2F;\",\n    \"`\": \"&#x60;\", /* IE allows backtick-delimited attributes?? */\n    \"&\": \"&amp;\"\n  };\n  const escape_one = function(c) {\n    return escape_map[c];\n  };\n\n  return function (x) {\n    return x.replace(/[&<>\"'`]/g, escape_one);\n  };\n})();\n\nBlaze._warn = function (msg) {\n  msg = 'Warning: ' + msg;\n\n  if ((typeof console !== 'undefined') && console.warn) {\n    console.warn(msg);\n  }\n};\n\nconst nativeBind = Function.prototype.bind;\n\n// An implementation of _.bind which allows better optimization.\n// See: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\nif (nativeBind) {\n  Blaze._bind = function (func, obj, ...rest) {\n    if (arguments.length === 2) {\n      return nativeBind.call(func, obj);\n    }\n\n    const args = [obj, ...rest];\n\n    return nativeBind.apply(func, args);\n  };\n}\nelse {\n  // A slower but backwards compatible version.\n  Blaze._bind = function(objA, objB) {\n    objA.bind(objB);\n  };\n}\n","let debugFunc;\n\n// We call into user code in many places, and it's nice to catch exceptions\n// propagated from user code immediately so that the whole system doesn't just\n// break.  Catching exceptions is easy; reporting them is hard.  This helper\n// reports exceptions.\n//\n// Usage:\n//\n// ```\n// try {\n//   // ... someStuff ...\n// } catch (e) {\n//   reportUIException(e);\n// }\n// ```\n//\n// An optional second argument overrides the default message.\n\n// Set this to `true` to cause `reportException` to throw\n// the next exception rather than reporting it.  This is\n// useful in unit tests that test error messages.\nBlaze._throwNextException = false;\n\nBlaze._reportException = function (e, msg) {\n  if (Blaze._throwNextException) {\n    Blaze._throwNextException = false;\n    throw e;\n  }\n\n  if (! debugFunc)\n    // adapted from Tracker\n    debugFunc = function () {\n      return (typeof Meteor !== \"undefined\" ? Meteor._debug :\n              ((typeof console !== \"undefined\") && console.log ? console.log :\n               function () {}));\n    };\n\n  // In Chrome, `e.stack` is a multiline string that starts with the message\n  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.\n  // `console.log` supplies the space between the two arguments.\n  debugFunc()(msg || 'Exception caught in template:', e.stack || e.message || e);\n};\n\n// It's meant to be used in `Promise` chains to report the error while not\n// \"swallowing\" it (i.e., the chain will still reject).\nBlaze._reportExceptionAndThrow = function (error) {\n  Blaze._reportException(error);\n  throw error;\n};\n\nBlaze._wrapCatchingExceptions = function (f, where) {\n  if (typeof f !== 'function')\n    return f;\n\n  return function (...arguments) {\n    try {\n      return f.apply(this, arguments);\n    } catch (e) {\n      Blaze._reportException(e, 'Exception in ' + where + ':');\n    }\n  };\n};\n","/// [new] Blaze.View([name], renderMethod)\n///\n/// Blaze.View is the building block of reactive DOM.  Views have\n/// the following features:\n///\n/// * lifecycle callbacks - Views are created, rendered, and destroyed,\n///   and callbacks can be registered to fire when these things happen.\n///\n/// * parent pointer - A View points to its parentView, which is the\n///   View that caused it to be rendered.  These pointers form a\n///   hierarchy or tree of Views.\n///\n/// * render() method - A View's render() method specifies the DOM\n///   (or HTML) content of the View.  If the method establishes\n///   reactive dependencies, it may be re-run.\n///\n/// * a DOMRange - If a View is rendered to DOM, its position and\n///   extent in the DOM are tracked using a DOMRange object.\n///\n/// When a View is constructed by calling Blaze.View, the View is\n/// not yet considered \"created.\"  It doesn't have a parentView yet,\n/// and no logic has been run to initialize the View.  All real\n/// work is deferred until at least creation time, when the onViewCreated\n/// callbacks are fired, which happens when the View is \"used\" in\n/// some way that requires it to be rendered.\n///\n/// ...more lifecycle stuff\n///\n/// `name` is an optional string tag identifying the View.  The only\n/// time it's used is when looking in the View tree for a View of a\n/// particular name; for example, data contexts are stored on Views\n/// of name \"with\".  Names are also useful when debugging, so in\n/// general it's good for functions that create Views to set the name.\n/// Views associated with templates have names of the form \"Template.foo\".\nimport { HTML } from 'meteor/htmljs';\n\n/**\n * A binding is either `undefined` (pending), `{ error }` (rejected), or\n * `{ value }` (resolved). Synchronous values are immediately resolved (i.e.,\n * `{ value }` is used). The other states are reserved for asynchronous bindings\n * (i.e., values wrapped with `Promise`s).\n * @typedef {{ error: unknown } | { value: unknown } | undefined} Binding\n */\n\n/**\n * @class\n * @summary Constructor for a View, which represents a reactive region of DOM.\n * @locus Client\n * @param {String} [name] Optional.  A name for this type of View.  See [`view.name`](#view_name).\n * @param {Function} renderFunction A function that returns [*renderable content*](#Renderable-Content).  In this function, `this` is bound to the View.\n */\nBlaze.View = function (name, render) {\n  if (! (this instanceof Blaze.View))\n    // called without `new`\n    return new Blaze.View(name, render);\n\n  if (typeof name === 'function') {\n    // omitted \"name\" argument\n    render = name;\n    name = '';\n  }\n  this.name = name;\n  this._render = render;\n\n  this._callbacks = {\n    created: null,\n    rendered: null,\n    destroyed: null\n  };\n\n  // Setting all properties here is good for readability,\n  // and also may help Chrome optimize the code by keeping\n  // the View object from changing shape too much.\n  this.isCreated = false;\n  this._isCreatedForExpansion = false;\n  this.isRendered = false;\n  this._isAttached = false;\n  this.isDestroyed = false;\n  this._isInRender = false;\n  this.parentView = null;\n  this._domrange = null;\n  // This flag is normally set to false except for the cases when view's parent\n  // was generated as part of expanding some syntactic sugar expressions or\n  // methods.\n  // Ex.: Blaze.renderWithData is an equivalent to creating a view with regular\n  // Blaze.render and wrapping it into {{#with data}}{{/with}} view. Since the\n  // users don't know anything about these generated parent views, Blaze needs\n  // this information to be available on views to make smarter decisions. For\n  // example: removing the generated parent view with the view on Blaze.remove.\n  this._hasGeneratedParent = false;\n  // Bindings accessible to children views (via view.lookup('name')) within the\n  // closest template view.\n  /** @type {Record<string, ReactiveVar<Binding>>} */\n  this._scopeBindings = {};\n\n  this.renderCount = 0;\n};\n\nBlaze.View.prototype._render = function () { return null; };\n\nBlaze.View.prototype.onViewCreated = function (cb) {\n  this._callbacks.created = this._callbacks.created || [];\n  this._callbacks.created.push(cb);\n};\n\nBlaze.View.prototype._onViewRendered = function (cb) {\n  this._callbacks.rendered = this._callbacks.rendered || [];\n  this._callbacks.rendered.push(cb);\n};\n\nBlaze.View.prototype.onViewReady = function (cb) {\n  const self = this;\n  const fire = function () {\n    Tracker.afterFlush(function () {\n      if (! self.isDestroyed) {\n        Blaze._withCurrentView(self, function () {\n          cb.call(self);\n        });\n      }\n    });\n  };\n  self._onViewRendered(function onViewRendered() {\n    if (self.isDestroyed)\n      return;\n    if (! self._domrange.attached)\n      self._domrange.onAttached(fire);\n    else\n      fire();\n  });\n};\n\nBlaze.View.prototype.onViewDestroyed = function (cb) {\n  this._callbacks.destroyed = this._callbacks.destroyed || [];\n  this._callbacks.destroyed.push(cb);\n};\nBlaze.View.prototype.removeViewDestroyedListener = function (cb) {\n  const destroyed = this._callbacks.destroyed;\n  if (! destroyed)\n    return;\n  const index = destroyed.lastIndexOf(cb);\n  if (index !== -1) {\n    // XXX You'd think the right thing to do would be splice, but _fireCallbacks\n    // gets sad if you remove callbacks while iterating over the list.  Should\n    // change this to use callback-hook or EventEmitter or something else that\n    // properly supports removal.\n    destroyed[index] = null;\n  }\n};\n\n/// View#autorun(func)\n///\n/// Sets up a Tracker autorun that is \"scoped\" to this View in two\n/// important ways: 1) Blaze.currentView is automatically set\n/// on every re-run, and 2) the autorun is stopped when the\n/// View is destroyed.  As with Tracker.autorun, the first run of\n/// the function is immediate, and a Computation object that can\n/// be used to stop the autorun is returned.\n///\n/// View#autorun is meant to be called from View callbacks like\n/// onViewCreated, or from outside the rendering process.  It may not\n/// be called before the onViewCreated callbacks are fired (too early),\n/// or from a render() method (too confusing).\n///\n/// Typically, autoruns that update the state\n/// of the View (as in Blaze.With) should be started from an onViewCreated\n/// callback.  Autoruns that update the DOM should be started\n/// from either onViewCreated (guarded against the absence of\n/// view._domrange), or onViewReady.\nBlaze.View.prototype.autorun = function (f, _inViewScope, displayName) {\n  const self = this;\n\n  // The restrictions on when View#autorun can be called are in order\n  // to avoid bad patterns, like creating a Blaze.View and immediately\n  // calling autorun on it.  A freshly created View is not ready to\n  // have logic run on it; it doesn't have a parentView, for example.\n  // It's when the View is materialized or expanded that the onViewCreated\n  // handlers are fired and the View starts up.\n  //\n  // Letting the render() method call `this.autorun()` is problematic\n  // because of re-render.  The best we can do is to stop the old\n  // autorun and start a new one for each render, but that's a pattern\n  // we try to avoid internally because it leads to helpers being\n  // called extra times, in the case where the autorun causes the\n  // view to re-render (and thus the autorun to be torn down and a\n  // new one established).\n  //\n  // We could lift these restrictions in various ways.  One interesting\n  // idea is to allow you to call `view.autorun` after instantiating\n  // `view`, and automatically wrap it in `view.onViewCreated`, deferring\n  // the autorun so that it starts at an appropriate time.  However,\n  // then we can't return the Computation object to the caller, because\n  // it doesn't exist yet.\n  if (! self.isCreated) {\n    throw new Error(\"View#autorun must be called from the created callback at the earliest\");\n  }\n  if (this._isInRender) {\n    throw new Error(\"Can't call View#autorun from inside render(); try calling it from the created or rendered callback\");\n  }\n\n  const templateInstanceFunc = Blaze.Template._currentTemplateInstanceFunc;\n\n  const func = function viewAutorun(c) {\n    return Blaze._withCurrentView(_inViewScope || self, function () {\n      return Blaze.Template._withTemplateInstanceFunc(\n        templateInstanceFunc, function () {\n          return f.call(self, c);\n        });\n    });\n  };\n\n  // Give the autorun function a better name for debugging and profiling.\n  // The `displayName` property is not part of the spec but browsers like Chrome\n  // and Firefox prefer it in debuggers over the name function was declared by.\n  func.displayName =\n    (self.name || 'anonymous') + ':' + (displayName || 'anonymous');\n  const comp = Tracker.autorun(func);\n\n  const stopComputation = function () { comp.stop(); };\n  self.onViewDestroyed(stopComputation);\n  comp.onStop(function () {\n    self.removeViewDestroyedListener(stopComputation);\n  });\n\n  return comp;\n};\n\nBlaze.View.prototype._errorIfShouldntCallSubscribe = function () {\n  const self = this;\n\n  if (! self.isCreated) {\n    throw new Error(\"View#subscribe must be called from the created callback at the earliest\");\n  }\n  if (self._isInRender) {\n    throw new Error(\"Can't call View#subscribe from inside render(); try calling it from the created or rendered callback\");\n  }\n  if (self.isDestroyed) {\n    throw new Error(\"Can't call View#subscribe from inside the destroyed callback, try calling it inside created or rendered.\");\n  }\n};\n\n/**\n * Just like Blaze.View#autorun, but with Meteor.subscribe instead of\n * Tracker.autorun. Stop the subscription when the view is destroyed.\n * @return {SubscriptionHandle} A handle to the subscription so that you can\n * see if it is ready, or stop it manually\n */\nBlaze.View.prototype.subscribe = function (args, options) {\n  const self = this;\n  options = options || {};\n\n  self._errorIfShouldntCallSubscribe();\n\n  let subHandle;\n  if (options.connection) {\n    subHandle = options.connection.subscribe.apply(options.connection, args);\n  } else {\n    subHandle = Meteor.subscribe.apply(Meteor, args);\n  }\n\n  self.onViewDestroyed(function () {\n    subHandle.stop();\n  });\n\n  return subHandle;\n};\n\nBlaze.View.prototype.firstNode = function () {\n  if (! this._isAttached)\n    throw new Error(\"View must be attached before accessing its DOM\");\n\n  return this._domrange.firstNode();\n};\n\nBlaze.View.prototype.lastNode = function () {\n  if (! this._isAttached)\n    throw new Error(\"View must be attached before accessing its DOM\");\n\n  return this._domrange.lastNode();\n};\n\nBlaze._fireCallbacks = function (view, which) {\n  Blaze._withCurrentView(view, function () {\n    Tracker.nonreactive(function fireCallbacks() {\n      const cbs = view._callbacks[which];\n      for (let i = 0, N = (cbs && cbs.length); i < N; i++)\n        cbs[i] && cbs[i].call(view);\n    });\n  });\n};\n\nBlaze._createView = function (view, parentView, forExpansion) {\n  if (view.isCreated)\n    throw new Error(\"Can't render the same View twice\");\n\n  view.parentView = (parentView || null);\n  view.isCreated = true;\n  if (forExpansion)\n    view._isCreatedForExpansion = true;\n\n  Blaze._fireCallbacks(view, 'created');\n};\n\nconst doFirstRender = function (view, initialContent) {\n  const domrange = new Blaze._DOMRange(initialContent);\n  view._domrange = domrange;\n  domrange.view = view;\n  view.isRendered = true;\n  Blaze._fireCallbacks(view, 'rendered');\n\n  let teardownHook = null;\n\n  domrange.onAttached(function attached(range, element) {\n    view._isAttached = true;\n\n    teardownHook = Blaze._DOMBackend.Teardown.onElementTeardown(\n      element, function teardown() {\n        Blaze._destroyView(view, true /* _skipNodes */);\n      });\n  });\n\n  // tear down the teardown hook\n  view.onViewDestroyed(function () {\n    if (teardownHook) teardownHook.stop();\n    teardownHook = null;\n  });\n\n  return domrange;\n};\n\n// Take an uncreated View `view` and create and render it to DOM,\n// setting up the autorun that updates the View.  Returns a new\n// DOMRange, which has been associated with the View.\n//\n// The private arguments `_workStack` and `_intoArray` are passed in\n// by Blaze._materializeDOM and are only present for recursive calls\n// (when there is some other _materializeView on the stack).  If\n// provided, then we avoid the mutual recursion of calling back into\n// Blaze._materializeDOM so that deep View hierarchies don't blow the\n// stack.  Instead, we push tasks onto workStack for the initial\n// rendering and subsequent setup of the View, and they are done after\n// we return.  When there is a _workStack, we do not return the new\n// DOMRange, but instead push it into _intoArray from a _workStack\n// task.\nBlaze._materializeView = function (view, parentView, _workStack, _intoArray) {\n  Blaze._createView(view, parentView);\n\n  let domrange;\n  let lastHtmljs;\n  // We don't expect to be called in a Computation, but just in case,\n  // wrap in Tracker.nonreactive.\n  Tracker.nonreactive(function () {\n    view.autorun(function doRender(c) {\n      // `view.autorun` sets the current view.\n      view.renderCount = view.renderCount + 1;\n      view._isInRender = true;\n      // Any dependencies that should invalidate this Computation come\n      // from this line:\n      const htmljs = view._render();\n      view._isInRender = false;\n\n      if (! c.firstRun && ! Blaze._isContentEqual(lastHtmljs, htmljs)) {\n        Tracker.nonreactive(function doMaterialize() {\n          // re-render\n          const rangesAndNodes = Blaze._materializeDOM(htmljs, [], view);\n          domrange.setMembers(rangesAndNodes);\n          Blaze._fireCallbacks(view, 'rendered');\n        });\n      }\n      lastHtmljs = htmljs;\n\n      // Causes any nested views to stop immediately, not when we call\n      // `setMembers` the next time around the autorun.  Otherwise,\n      // helpers in the DOM tree to be replaced might be scheduled\n      // to re-run before we have a chance to stop them.\n      Tracker.onInvalidate(function () {\n        if (domrange) {\n          domrange.destroyMembers();\n        }\n      });\n    }, undefined, 'materialize');\n\n    // first render.  lastHtmljs is the first htmljs.\n    let initialContents;\n    if (! _workStack) {\n      initialContents = Blaze._materializeDOM(lastHtmljs, [], view);\n      domrange = doFirstRender(view, initialContents);\n      initialContents = null; // help GC because we close over this scope a lot\n    } else {\n      // We're being called from Blaze._materializeDOM, so to avoid\n      // recursion and save stack space, provide a description of the\n      // work to be done instead of doing it.  Tasks pushed onto\n      // _workStack will be done in LIFO order after we return.\n      // The work will still be done within a Tracker.nonreactive,\n      // because it will be done by some call to Blaze._materializeDOM\n      // (which is always called in a Tracker.nonreactive).\n      initialContents = [];\n      // push this function first so that it happens last\n      _workStack.push(function () {\n        domrange = doFirstRender(view, initialContents);\n        initialContents = null; // help GC because of all the closures here\n        _intoArray.push(domrange);\n      });\n      // now push the task that calculates initialContents\n      _workStack.push(Blaze._bind(Blaze._materializeDOM, null,\n                             lastHtmljs, initialContents, view, _workStack));\n    }\n  });\n\n  if (! _workStack) {\n    return domrange;\n  } else {\n    return null;\n  }\n};\n\n// Expands a View to HTMLjs, calling `render` recursively on all\n// Views and evaluating any dynamic attributes.  Calls the `created`\n// callback, but not the `materialized` or `rendered` callbacks.\n// Destroys the view immediately, unless called in a Tracker Computation,\n// in which case the view will be destroyed when the Computation is\n// invalidated.  If called in a Tracker Computation, the result is a\n// reactive string; that is, the Computation will be invalidated\n// if any changes are made to the view or subviews that might affect\n// the HTML.\nBlaze._expandView = function (view, parentView) {\n  Blaze._createView(view, parentView, true /*forExpansion*/);\n\n  view._isInRender = true;\n  const htmljs = Blaze._withCurrentView(view, function () {\n    return view._render();\n  });\n  view._isInRender = false;\n\n  const result = Blaze._expand(htmljs, view);\n\n  if (Tracker.active) {\n    Tracker.onInvalidate(function () {\n      Blaze._destroyView(view);\n    });\n  } else {\n    Blaze._destroyView(view);\n  }\n\n  return result;\n};\n\n// Options: `parentView`\nBlaze._HTMLJSExpander = HTML.TransformingVisitor.extend();\nBlaze._HTMLJSExpander.def({\n  visitObject: function (x) {\n    if (x instanceof Blaze.Template)\n      x = x.constructView();\n    if (x instanceof Blaze.View)\n      return Blaze._expandView(x, this.parentView);\n\n    // this will throw an error; other objects are not allowed!\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n  },\n  visitAttributes: function (attrs) {\n    // expand dynamic attributes\n    if (typeof attrs === 'function')\n      attrs = Blaze._withCurrentView(this.parentView, attrs);\n\n    // call super (e.g. for case where `attrs` is an array)\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\n  },\n  visitAttribute: function (name, value, tag) {\n    // expand attribute values that are functions.  Any attribute value\n    // that contains Views must be wrapped in a function.\n    if (typeof value === 'function')\n      value = Blaze._withCurrentView(this.parentView, value);\n\n    return HTML.TransformingVisitor.prototype.visitAttribute.call(\n      this, name, value, tag);\n  }\n});\n\n// Return Blaze.currentView, but only if it is being rendered\n// (i.e. we are in its render() method).\nconst currentViewIfRendering = function () {\n  const view = Blaze.currentView;\n  return (view && view._isInRender) ? view : null;\n};\n\nBlaze._expand = function (htmljs, parentView) {\n  parentView = parentView || currentViewIfRendering();\n  return (new Blaze._HTMLJSExpander(\n    {parentView: parentView})).visit(htmljs);\n};\n\nBlaze._expandAttributes = function (attrs, parentView) {\n  parentView = parentView || currentViewIfRendering();\n  const expanded = (new Blaze._HTMLJSExpander(\n    {parentView: parentView})).visitAttributes(attrs);\n  return expanded || {};\n};\n\nBlaze._destroyView = function (view, _skipNodes) {\n  if (view.isDestroyed)\n    return;\n  view.isDestroyed = true;\n\n\n  // Destroy views and elements recursively.  If _skipNodes,\n  // only recurse up to views, not elements, for the case where\n  // the backend (jQuery) is recursing over the elements already.\n\n  if (view._domrange) view._domrange.destroyMembers(_skipNodes);\n\n  // XXX: fire callbacks after potential members are destroyed\n  // otherwise it's tracker.flush will cause the above line will\n  // not be called and their views won't be destroyed\n  // Involved issues: DOMRange \"Must be attached\" error, mem leak\n\n  Blaze._fireCallbacks(view, 'destroyed');\n};\n\nBlaze._destroyNode = function (node) {\n  if (node.nodeType === 1)\n    Blaze._DOMBackend.Teardown.tearDownElement(node);\n};\n\n// Are the HTMLjs entities `a` and `b` the same?  We could be\n// more elaborate here but the point is to catch the most basic\n// cases.\nBlaze._isContentEqual = function (a, b) {\n  if (a instanceof HTML.Raw) {\n    return (b instanceof HTML.Raw) && (a.value === b.value);\n  } else if (a == null) {\n    return (b == null);\n  } else {\n    return (a === b) &&\n      ((typeof a === 'number') || (typeof a === 'boolean') ||\n       (typeof a === 'string'));\n  }\n};\n\n/**\n * @summary The View corresponding to the current template helper, event handler, callback, or autorun.  If there isn't one, `null`.\n * @locus Client\n * @type {Blaze.View}\n */\nBlaze.currentView = null;\n\n/**\n * @template T\n * @param {Blaze.View} view\n * @param {function(): T} func\n * @returns {T}\n */\nBlaze._withCurrentView = function (view, func) {\n  const oldView = Blaze.currentView;\n  try {\n    Blaze.currentView = view;\n    return func();\n  } finally {\n    Blaze.currentView = oldView;\n  }\n};\n\n// Blaze.render publicly takes a View or a Template.\n// Privately, it takes any HTMLJS (extended with Views and Templates)\n// except null or undefined, or a function that returns any extended\n// HTMLJS.\nconst checkRenderContent = function (content) {\n  if (content === null)\n    throw new Error(\"Can't render null\");\n  if (typeof content === 'undefined')\n    throw new Error(\"Can't render undefined\");\n\n  if ((content instanceof Blaze.View) ||\n      (content instanceof Blaze.Template) ||\n      (typeof content === 'function'))\n    return;\n\n  try {\n    // Throw if content doesn't look like HTMLJS at the top level\n    // (i.e. verify that this is an HTML.Tag, or an array,\n    // or a primitive, etc.)\n    (new HTML.Visitor).visit(content);\n  } catch (e) {\n    // Make error message suitable for public API\n    throw new Error(\"Expected Template or View\");\n  }\n};\n\n// For Blaze.render and Blaze.toHTML, take content and\n// wrap it in a View, unless it's a single View or\n// Template already.\nconst contentAsView = function (content) {\n  checkRenderContent(content);\n\n  if (content instanceof Blaze.Template) {\n    return content.constructView();\n  } else if (content instanceof Blaze.View) {\n    return content;\n  } else {\n    let func = content;\n    if (typeof func !== 'function') {\n      func = function () {\n        return content;\n      };\n    }\n    return Blaze.View('render', func);\n  }\n};\n\n// For Blaze.renderWithData and Blaze.toHTMLWithData, wrap content\n// in a function, if necessary, so it can be a content arg to\n// a Blaze.With.\nconst contentAsFunc = function (content) {\n  checkRenderContent(content);\n\n  if (typeof content !== 'function') {\n    return function () {\n      return content;\n    };\n  } else {\n    return content;\n  }\n};\n\nBlaze.__rootViews = [];\n\n/**\n * @summary Renders a template or View to DOM nodes and inserts it into the DOM, returning a rendered [View](#Blaze-View) which can be passed to [`Blaze.remove`](#Blaze-remove).\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.  If a template, a View object is [constructed](#template_constructview).  If a View, it must be an unrendered View, which becomes a rendered View and is returned.\n * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n */\nBlaze.render = function (content, parentElement, nextNode, parentView) {\n  if (! parentElement) {\n    Blaze._warn(\"Blaze.render without a parent element is deprecated. \" +\n                \"You must specify where to insert the rendered content.\");\n  }\n\n  if (nextNode instanceof Blaze.View) {\n    // handle omitted nextNode\n    parentView = nextNode;\n    nextNode = null;\n  }\n\n  // parentElement must be a DOM node. in particular, can't be the\n  // result of a call to `$`. Can't check if `parentElement instanceof\n  // Node` since 'Node' is undefined in IE8.\n  if (parentElement && typeof parentElement.nodeType !== 'number')\n    throw new Error(\"'parentElement' must be a DOM node\");\n  if (nextNode && typeof nextNode.nodeType !== 'number') // 'nextNode' is optional\n    throw new Error(\"'nextNode' must be a DOM node\");\n\n  parentView = parentView || currentViewIfRendering();\n\n  const view = contentAsView(content);\n\n  // TODO: this is only needed in development\n  if (!parentView) {\n    view.onViewCreated(function () {\n      Blaze.__rootViews.push(view);\n    });\n\n    view.onViewDestroyed(function () {\n      let index = Blaze.__rootViews.indexOf(view);\n      if (index > -1) {\n        Blaze.__rootViews.splice(index, 1);\n      }\n    });\n  }\n\n  Blaze._materializeView(view, parentView);\n  if (parentElement) {\n    view._domrange.attach(parentElement, nextNode);\n  }\n\n  return view;\n};\n\nBlaze.insert = function (view, parentElement, nextNode) {\n  Blaze._warn(\"Blaze.insert has been deprecated.  Specify where to insert the \" +\n              \"rendered content in the call to Blaze.render.\");\n\n  if (! (view && (view._domrange instanceof Blaze._DOMRange)))\n    throw new Error(\"Expected template rendered with Blaze.render\");\n\n  view._domrange.attach(parentElement, nextNode);\n};\n\n/**\n * @summary Renders a template or View to DOM nodes with a data context.  Otherwise identical to `Blaze.render`.\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.\n * @param {Object|Function} data The data context to use, or a function returning a data context.  If a function is provided, it will be reactively re-run.\n * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n */\nBlaze.renderWithData = function (content, data, parentElement, nextNode, parentView) {\n  // We defer the handling of optional arguments to Blaze.render.  At this point,\n  // `nextNode` may actually be `parentView`.\n  return Blaze.render(Blaze._TemplateWith(data, contentAsFunc(content)),\n                          parentElement, nextNode, parentView);\n};\n\n/**\n * @summary Removes a rendered View from the DOM, stopping all reactive updates and event listeners on it. Also destroys the Blaze.Template instance associated with the view.\n * @locus Client\n * @param {Blaze.View} renderedView The return value from `Blaze.render` or `Blaze.renderWithData`, or the `view` property of a Blaze.Template instance. Calling `Blaze.remove(Template.instance().view)` from within a template event handler will destroy the view as well as that template and trigger the template's `onDestroyed` handlers.\n */\nBlaze.remove = function (view) {\n  if (! (view && (view._domrange instanceof Blaze._DOMRange)))\n    throw new Error(\"Expected template rendered with Blaze.render\");\n\n  while (view) {\n    if (! view.isDestroyed) {\n      const range = view._domrange;\n      range.destroy();\n\n      if (range.attached && ! range.parentRange) {\n        range.detach();\n      }\n    }\n\n    view = view._hasGeneratedParent && view.parentView;\n  }\n};\n\n/**\n * @summary Renders a template or View to a string of HTML.\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n */\nBlaze.toHTML = function (content, parentView) {\n  parentView = parentView || currentViewIfRendering();\n\n  return HTML.toHTML(Blaze._expandView(contentAsView(content), parentView));\n};\n\n/**\n * @summary Renders a template or View to HTML with a data context.  Otherwise identical to `Blaze.toHTML`.\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n * @param {Object|Function} data The data context to use, or a function returning a data context.\n */\nBlaze.toHTMLWithData = function (content, data, parentView) {\n  parentView = parentView || currentViewIfRendering();\n\n  return HTML.toHTML(Blaze._expandView(Blaze._TemplateWith(\n    data, contentAsFunc(content)), parentView));\n};\n\nBlaze._toText = function (htmljs, parentView, textMode) {\n  if (typeof htmljs === 'function')\n    throw new Error(\"Blaze._toText doesn't take a function, just HTMLjs\");\n\n  if ((parentView != null) && ! (parentView instanceof Blaze.View)) {\n    // omitted parentView argument\n    textMode = parentView;\n    parentView = null;\n  }\n  parentView = parentView || currentViewIfRendering();\n\n  if (! textMode)\n    throw new Error(\"textMode required\");\n  if (! (textMode === HTML.TEXTMODE.STRING ||\n         textMode === HTML.TEXTMODE.RCDATA ||\n         textMode === HTML.TEXTMODE.ATTRIBUTE))\n    throw new Error(\"Unknown textMode: \" + textMode);\n\n  return HTML.toText(Blaze._expand(htmljs, parentView), textMode);\n};\n\n/**\n * @summary Returns the current data context, or the data context that was used when rendering a particular DOM element or View from a Meteor template.\n * @locus Client\n * @param {DOMElement|Blaze.View} [elementOrView] Optional.  An element that was rendered by a Meteor, or a View.\n */\nBlaze.getData = function (elementOrView) {\n  let theWith;\n\n  if (! elementOrView) {\n    theWith = Blaze.getView('with');\n  } else if (elementOrView instanceof Blaze.View) {\n    const view = elementOrView;\n    theWith = (view.name === 'with' ? view :\n               Blaze.getView(view, 'with'));\n  } else if (typeof elementOrView.nodeType === 'number') {\n    if (elementOrView.nodeType !== 1)\n      throw new Error(\"Expected DOM element\");\n    theWith = Blaze.getView(elementOrView, 'with');\n  } else {\n    throw new Error(\"Expected DOM element or View\");\n  }\n\n  return theWith ? theWith.dataVar.get()?.value : null;\n};\n\n// For back-compat\nBlaze.getElementData = function (element) {\n  Blaze._warn(\"Blaze.getElementData has been deprecated.  Use \" +\n              \"Blaze.getData(element) instead.\");\n\n  if (element.nodeType !== 1)\n    throw new Error(\"Expected DOM element\");\n\n  return Blaze.getData(element);\n};\n\n// Both arguments are optional.\n\n/**\n * @summary Gets either the current View, or the View enclosing the given DOM element.\n * @locus Client\n * @param {DOMElement} [element] Optional.  If specified, the View enclosing `element` is returned.\n */\nBlaze.getView = function (elementOrView, _viewName) {\n  let viewName = _viewName;\n\n  if ((typeof elementOrView) === 'string') {\n    // omitted elementOrView; viewName present\n    viewName = elementOrView;\n    elementOrView = null;\n  }\n\n  // We could eventually shorten the code by folding the logic\n  // from the other methods into this method.\n  if (! elementOrView) {\n    return Blaze._getCurrentView(viewName);\n  } else if (elementOrView instanceof Blaze.View) {\n    return Blaze._getParentView(elementOrView, viewName);\n  } else if (typeof elementOrView.nodeType === 'number') {\n    return Blaze._getElementView(elementOrView, viewName);\n  } else {\n    throw new Error(\"Expected DOM element or View\");\n  }\n};\n\n// Gets the current view or its nearest ancestor of name\n// `name`.\nBlaze._getCurrentView = function (name) {\n  let view = Blaze.currentView;\n  // Better to fail in cases where it doesn't make sense\n  // to use Blaze._getCurrentView().  There will be a current\n  // view anywhere it does.  You can check Blaze.currentView\n  // if you want to know whether there is one or not.\n  if (! view)\n    throw new Error(\"There is no current view\");\n\n  if (name) {\n    while (view && view.name !== name)\n      view = view.parentView;\n    return view || null;\n  } else {\n    // Blaze._getCurrentView() with no arguments just returns\n    // Blaze.currentView.\n    return view;\n  }\n};\n\nBlaze._getParentView = function (view, name) {\n  let v = view.parentView;\n\n  if (name) {\n    while (v && v.name !== name)\n      v = v.parentView;\n  }\n\n  return v || null;\n};\n\nBlaze._getElementView = function (elem, name) {\n  let range = Blaze._DOMRange.forElement(elem);\n  let view = null;\n  while (range && ! view) {\n    view = (range.view || null);\n    if (! view) {\n      if (range.parentRange)\n        range = range.parentRange;\n      else\n        range = Blaze._DOMRange.forElement(range.parentElement);\n    }\n  }\n\n  if (name) {\n    while (view && view.name !== name)\n      view = view.parentView;\n    return view || null;\n  } else {\n    return view;\n  }\n};\n\nBlaze._addEventMap = function (view, eventMap, thisInHandler) {\n  thisInHandler = (thisInHandler || null);\n  const handles = [];\n\n  if (! view._domrange)\n    throw new Error(\"View must have a DOMRange\");\n\n  view._domrange.onAttached(function attached_eventMaps(range, element) {\n    Object.keys(eventMap).forEach(function (spec) {\n      let handler = eventMap[spec];\n      const clauses = spec.split(/,\\s+/);\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\n      clauses.forEach(function (clause) {\n        const parts = clause.split(/\\s+/);\n        if (parts.length === 0)\n          return;\n\n        const newEvents = parts.shift();\n        const selector = parts.join(' ');\n        handles.push(Blaze._EventSupport.listen(\n          element, newEvents, selector,\n          function (evt) {\n            if (! range.containsElement(evt.currentTarget, selector, newEvents))\n              return null;\n            const handlerThis = thisInHandler || this;\n            const handlerArgs = arguments;\n            return Blaze._withCurrentView(view, function () {\n              return handler.apply(handlerThis, handlerArgs);\n            });\n          },\n          range, function (r) {\n            return r.parentRange;\n          }));\n      });\n    });\n  });\n\n  view.onViewDestroyed(function () {\n    handles.forEach(function (h) {\n      h.stop();\n    });\n    handles.length = 0;\n  });\n};\n","import has from 'lodash.has';\nimport isObject from 'lodash.isobject';\n\nBlaze._calculateCondition = function (cond) {\n  if (HTML.isArray(cond) && cond.length === 0) return false;\n  return !!cond;\n};\n\n/**\n * @summary Constructs a View that renders content with a data context.\n * @locus Client\n * @param {Object|Function} data An object to use as the data context, or a function returning such an object.  If a\n *   function is provided, it will be reactively re-run.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#Renderable-Content).\n */\nBlaze.With = function (data, contentFunc) {\n  const view = Blaze.View('with', contentFunc);\n\n  view.dataVar = null;\n  view.onViewCreated(() => {\n    view.dataVar = _createBinding(view, data, 'setData');\n  });\n\n  return view;\n};\n\n\n/**\n * @summary Shallow compare of two bindings.\n * @param {Binding} x\n * @param {Binding} y\n */\nfunction _isEqualBinding(x, y) {\n  if (typeof x === 'object' && typeof y === 'object') {\n    return x.error === y.error && ReactiveVar._isEqual(x.value, y.value);\n  }\n  else {\n    return ReactiveVar._isEqual(x, y);\n  }\n}\n\n/**\n * @template T\n * @param {T} x\n * @returns {T}\n */\nfunction _identity(x) {\n  return x;\n}\n\n/**\n * Attaches a single binding to the instantiated view.\n * @template T, U\n * @param {ReactiveVar<U>} reactiveVar Target view.\n * @param {Promise<T> | T} value Bound value.\n * @param {function(T): U} [mapper] Maps the computed value before store.\n */\nfunction _setBindingValue(reactiveVar, value, mapper = _identity) {\n  if (value && typeof value.then === 'function') {\n    value.then(\n      value => reactiveVar.set({ value: mapper(value) }),\n      error => reactiveVar.set({ error }),\n    );\n  } else {\n    reactiveVar.set({ value: mapper(value) });\n  }\n}\n\n/**\n * @template T, U\n * @param {Blaze.View} view Target view.\n * @param {Promise<T> | T | function(): (Promise<T> | T)} binding Binding value or its getter.\n * @param {string} [displayName] Autorun's display name.\n * @param {function(T): U} [mapper] Maps the computed value before store.\n * @returns {ReactiveVar<U>}\n */\nfunction _createBinding(view, binding, displayName, mapper) {\n  const reactiveVar = new ReactiveVar(undefined, _isEqualBinding);\n  if (typeof binding === 'function') {\n    view.autorun(\n      () => _setBindingValue(reactiveVar, binding(), mapper),\n      view.parentView,\n      displayName,\n    );\n  } else {\n    _setBindingValue(reactiveVar, binding, mapper);\n  }\n\n  return reactiveVar;\n}\n\n/**\n * Attaches bindings to the instantiated view.\n * @param {Object} bindings A dictionary of bindings, each binding name\n * corresponds to a value or a function that will be reactively re-run.\n * @param {Blaze.View} view The target.\n */\nBlaze._attachBindingsToView = function (bindings, view) {\n  view.onViewCreated(function () {\n    Object.entries(bindings).forEach(function ([name, binding]) {\n      view._scopeBindings[name] = _createBinding(view, binding);\n    });\n  });\n};\n\n/**\n * @summary Constructs a View setting the local lexical scope in the block.\n * @param {Function} bindings Dictionary mapping names of bindings to\n * values or computations to reactively re-run.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#Renderable-Content).\n */\nBlaze.Let = function (bindings, contentFunc) {\n  var view = Blaze.View('let', contentFunc);\n  Blaze._attachBindingsToView(bindings, view);\n\n  return view;\n};\n\n/**\n * @summary Constructs a View that renders content conditionally.\n * @locus Client\n * @param {Function} conditionFunc A function to reactively re-run.  Whether the result is truthy or falsy determines\n *   whether `contentFunc` or `elseFunc` is shown.  An empty array is considered falsy.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#Renderable-Content).\n * @param {Function} [elseFunc] Optional.  A Function that returns [*renderable content*](#Renderable-Content).  If no\n *   `elseFunc` is supplied, no content is shown in the \"else\" case.\n */\nBlaze.If = function (conditionFunc, contentFunc, elseFunc, _not) {\n  const view = Blaze.View(_not ? 'unless' : 'if', function () {\n    // Render only if the binding has a value, i.e., it's either synchronous or\n    // has resolved. Rejected `Promise`s are NOT rendered.\n    const condition = view.__conditionVar.get();\n    if (condition && 'value' in condition) {\n      return condition.value ? contentFunc() : (elseFunc ? elseFunc() : null);\n    }\n\n    return null;\n  });\n\n  view.__conditionVar = null;\n  view.onViewCreated(() => {\n    view.__conditionVar = _createBinding(\n      view,\n      conditionFunc,\n      'condition',\n      // Store only the actual condition.\n      value => !Blaze._calculateCondition(value) !== !_not,\n    );\n  });\n\n  return view;\n};\n\n/**\n * @summary An inverted [`Blaze.If`](#Blaze-If).\n * @locus Client\n * @param {Function} conditionFunc A function to reactively re-run.  If the result is falsy, `contentFunc` is shown,\n *   otherwise `elseFunc` is shown.  An empty array is considered falsy.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#Renderable-Content).\n * @param {Function} [elseFunc] Optional.  A Function that returns [*renderable content*](#Renderable-Content).  If no\n *   `elseFunc` is supplied, no content is shown in the \"else\" case.\n */\nBlaze.Unless = function (conditionFunc, contentFunc, elseFunc) {\n  return Blaze.If(conditionFunc, contentFunc, elseFunc, true /*_not*/);\n};\n\n/**\n * @summary Constructs a View that renders `contentFunc` for each item in a sequence.\n * @locus Client\n * @param {Function} argFunc A function to reactively re-run. The function can\n * return one of two options:\n *\n * 1. An object with two fields: '_variable' and '_sequence'. Each iterates over\n *   '_sequence', it may be a Cursor, an array, null, or undefined. Inside the\n *   Each body you will be able to get the current item from the sequence using\n *   the name specified in the '_variable' field.\n *\n * 2. Just a sequence (Cursor, array, null, or undefined) not wrapped into an\n *   object. Inside the Each body, the current item will be set as the data\n *   context.\n * @param {Function} contentFunc A Function that returns  [*renderable\n * content*](#Renderable-Content).\n * @param {Function} [elseFunc] A Function that returns [*renderable\n * content*](#Renderable-Content) to display in the case when there are no items\n * in the sequence.\n */\nBlaze.Each = function (argFunc, contentFunc, elseFunc) {\n  const eachView = Blaze.View('each', function () {\n    const subviews = this.initialSubviews;\n    this.initialSubviews = null;\n    if (this._isCreatedForExpansion) {\n      this.expandedValueDep = new Tracker.Dependency;\n      this.expandedValueDep.depend();\n    }\n    return subviews;\n  });\n  eachView.initialSubviews = [];\n  eachView.numItems = 0;\n  eachView.inElseMode = false;\n  eachView.stopHandle = null;\n  eachView.contentFunc = contentFunc;\n  eachView.elseFunc = elseFunc;\n  eachView.argVar = undefined;\n  eachView.variableName = null;\n\n  // update the @index value in the scope of all subviews in the range\n  const updateIndices = function (from, to) {\n    if (to === undefined) {\n      to = eachView.numItems - 1;\n    }\n\n    for (let i = from; i <= to; i++) {\n      const view = eachView._domrange.members[i].view;\n      view._scopeBindings['@index'].set({ value: i });\n    }\n  };\n\n  eachView.onViewCreated(function () {\n    // We evaluate `argFunc` in `Tracker.autorun` to ensure `Blaze.currentView`\n    // is always set when it runs.\n    eachView.argVar = _createBinding(\n      eachView,\n      // Unwrap a sequence reactively (`{{#each x in xs}}`).\n      () => {\n        let maybeSequence = argFunc();\n        if (isObject(maybeSequence) && has(maybeSequence, '_sequence')) {\n          eachView.variableName = maybeSequence._variable || null;\n          maybeSequence = maybeSequence._sequence;\n        }\n        return maybeSequence;\n      },\n      'collection',\n    );\n\n    eachView.stopHandle = ObserveSequence.observe(function () {\n      return eachView.argVar.get()?.value;\n    }, {\n      addedAt: function (id, item, index) {\n        Tracker.nonreactive(function () {\n          let newItemView;\n          if (eachView.variableName) {\n            // new-style #each (as in {{#each item in items}})\n            // doesn't create a new data context\n            newItemView = Blaze.View('item', eachView.contentFunc);\n          } else {\n            newItemView = Blaze.With(item, eachView.contentFunc);\n          }\n\n          eachView.numItems++;\n\n          const bindings = {};\n          bindings['@index'] = index;\n          if (eachView.variableName) {\n            bindings[eachView.variableName] = item;\n          }\n          Blaze._attachBindingsToView(bindings, newItemView);\n\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView._domrange) {\n            if (eachView.inElseMode) {\n              eachView._domrange.removeMember(0);\n              eachView.inElseMode = false;\n            }\n\n            const range = Blaze._materializeView(newItemView, eachView);\n            eachView._domrange.addMember(range, index);\n            updateIndices(index);\n          } else {\n            eachView.initialSubviews.splice(index, 0, newItemView);\n          }\n        });\n      },\n      removedAt: function (id, item, index) {\n        Tracker.nonreactive(function () {\n          eachView.numItems--;\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView._domrange) {\n            eachView._domrange.removeMember(index);\n            updateIndices(index);\n            if (eachView.elseFunc && eachView.numItems === 0) {\n              eachView.inElseMode = true;\n              eachView._domrange.addMember(\n                Blaze._materializeView(\n                  Blaze.View('each_else',eachView.elseFunc),\n                  eachView), 0);\n            }\n          } else {\n            eachView.initialSubviews.splice(index, 1);\n          }\n        });\n      },\n      changedAt: function (id, newItem, oldItem, index) {\n        Tracker.nonreactive(function () {\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else {\n            let itemView;\n            if (eachView._domrange) {\n              itemView = eachView._domrange.getMember(index).view;\n            } else {\n              itemView = eachView.initialSubviews[index];\n            }\n            if (eachView.variableName) {\n              itemView._scopeBindings[eachView.variableName].set({ value: newItem });\n            } else {\n              itemView.dataVar.set({ value: newItem });\n            }\n          }\n        });\n      },\n      movedTo: function (id, item, fromIndex, toIndex) {\n        Tracker.nonreactive(function () {\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView._domrange) {\n            eachView._domrange.moveMember(fromIndex, toIndex);\n            updateIndices(\n              Math.min(fromIndex, toIndex), Math.max(fromIndex, toIndex));\n          } else {\n            const subviews = eachView.initialSubviews;\n            const itemView = subviews[fromIndex];\n            subviews.splice(fromIndex, 1);\n            subviews.splice(toIndex, 0, itemView);\n          }\n        });\n      }\n    });\n\n    if (eachView.elseFunc && eachView.numItems === 0) {\n      eachView.inElseMode = true;\n      eachView.initialSubviews[0] =\n        Blaze.View('each_else', eachView.elseFunc);\n    }\n  });\n\n  eachView.onViewDestroyed(function () {\n    if (eachView.stopHandle)\n      eachView.stopHandle.stop();\n  });\n\n  return eachView;\n};\n\n/**\n * Create a new `Blaze.Let` view that unwraps the given value.\n * @param {unknown} value\n * @returns {Blaze.View}\n */\nBlaze._Await = function (value) {\n  return Blaze.Let({ value }, Blaze._AwaitContent);\n};\n\nBlaze._AwaitContent = function () {\n  return Blaze.currentView._scopeBindings.value.get()?.value;\n};\n\nBlaze._TemplateWith = function (arg, contentFunc) {\n  let w;\n\n  let argFunc = arg;\n  if (typeof arg !== 'function') {\n    argFunc = function () {\n      return arg;\n    };\n  }\n\n  // This is a little messy.  When we compile `{{> Template.contentBlock}}`, we\n  // wrap it in Blaze._InOuterTemplateScope in order to skip the intermediate\n  // parent Views in the current template.  However, when there's an argument\n  // (`{{> Template.contentBlock arg}}`), the argument needs to be evaluated\n  // in the original scope.  There's no good order to nest\n  // Blaze._InOuterTemplateScope and Blaze._TemplateWith to achieve this,\n  // so we wrap argFunc to run it in the \"original parentView\" of the\n  // Blaze._InOuterTemplateScope.\n  //\n  // To make this better, reconsider _InOuterTemplateScope as a primitive.\n  // Longer term, evaluate expressions in the proper lexical scope.\n  const wrappedArgFunc = function () {\n    let viewToEvaluateArg = null;\n    if (w.parentView && w.parentView.name === 'InOuterTemplateScope') {\n      viewToEvaluateArg = w.parentView.originalParentView;\n    }\n    if (viewToEvaluateArg) {\n      return Blaze._withCurrentView(viewToEvaluateArg, argFunc);\n    } else {\n      return argFunc();\n    }\n  };\n\n  const wrappedContentFunc = function () {\n    let content = contentFunc.call(this);\n\n    // Since we are generating the Blaze._TemplateWith view for the\n    // user, set the flag on the child view.  If `content` is a template,\n    // construct the View so that we can set the flag.\n    if (content instanceof Blaze.Template) {\n      content = content.constructView();\n    }\n    if (content instanceof Blaze.View) {\n      content._hasGeneratedParent = true;\n    }\n\n    return content;\n  };\n\n  w = Blaze.With(wrappedArgFunc, wrappedContentFunc);\n  w.__isTemplateWith = true;\n  return w;\n};\n\nBlaze._InOuterTemplateScope = function (templateView, contentFunc) {\n  const view = Blaze.View('InOuterTemplateScope', contentFunc);\n  let parentView = templateView.parentView;\n\n  // Hack so that if you call `{{> foo bar}}` and it expands into\n  // `{{#with bar}}{{> foo}}{{/with}}`, and then `foo` is a template\n  // that inserts `{{> Template.contentBlock}}`, the data context for\n  // `Template.contentBlock` is not `bar` but the one enclosing that.\n  if (parentView.__isTemplateWith)\n    parentView = parentView.parentView;\n\n  view.onViewCreated(function () {\n    this.originalParentView = this.parentView;\n    this.parentView = parentView;\n    this.__childDoesntStartNewLexicalScope = true;\n  });\n  return view;\n};\n\n","import has from 'lodash.has';\n\n/** @param {function(Binding): boolean} fn */\nfunction _createBindingsHelper(fn) {\n  /** @param {string[]} names */\n  return (...names) => {\n    const view = Blaze.currentView;\n\n    // There's either zero arguments (i.e., check all bindings) or an additional\n    // \"hash\" argument that we have to ignore.\n    names = names.length === 0\n      // TODO: Should we walk up the bindings here?\n      ? Object.keys(view._scopeBindings)\n      : names.slice(0, -1);\n\n    return names.some(name => {\n      const binding = _lexicalBindingLookup(view, name);\n      if (!binding) {\n        throw new Error(`Binding for \"${name}\" was not found.`);\n      }\n\n      return fn(binding.get());\n    });\n  };\n}\n\nBlaze._globalHelpers = {\n  /** @summary Check whether any of the given bindings (or all if none given) is still pending. */\n  '@pending': _createBindingsHelper(binding => binding === undefined),\n  /** @summary Check whether any of the given bindings (or all if none given) has rejected. */\n  '@rejected': _createBindingsHelper(binding => !!binding && 'error' in binding),\n  /** @summary Check whether any of the given bindings (or all if none given) has resolved. */\n  '@resolved': _createBindingsHelper(binding => !!binding && 'value' in binding),\n};\n\n// Documented as Template.registerHelper.\n// This definition also provides back-compat for `UI.registerHelper`.\nBlaze.registerHelper = function (name, func) {\n  Blaze._globalHelpers[name] = func;\n};\n\n// Also documented as Template.deregisterHelper\nBlaze.deregisterHelper = function(name) {\n  delete Blaze._globalHelpers[name];\n};\n\nconst bindIfIsFunction = function (x, target) {\n  if (typeof x !== 'function')\n    return x;\n  return Blaze._bind(x, target);\n};\n\n// If `x` is a function, binds the value of `this` for that function\n// to the current data context.\nconst bindDataContext = function (x) {\n  if (typeof x === 'function') {\n    return function (...args) {\n      let data = Blaze.getData();\n      if (data == null)\n        data = {};\n      return x.apply(data, args);\n    };\n  }\n  return x;\n};\n\nBlaze._OLDSTYLE_HELPER = {};\n\nBlaze._getTemplateHelper = function (template, name, tmplInstanceFunc) {\n  // XXX COMPAT WITH 0.9.3\n  let isKnownOldStyleHelper = false;\n\n  if (template.__helpers.has(name)) {\n    const helper = template.__helpers.get(name);\n    if (helper === Blaze._OLDSTYLE_HELPER) {\n      isKnownOldStyleHelper = true;\n    } else if (helper != null) {\n      const printName = `${template.viewName} ${name}`;\n      return wrapHelper(bindDataContext(helper), tmplInstanceFunc, printName);\n    } else {\n      return null;\n    }\n  }\n\n  // old-style helper\n  if (name in template) {\n    // Only warn once per helper\n    if (! isKnownOldStyleHelper) {\n      template.__helpers.set(name, Blaze._OLDSTYLE_HELPER);\n      if (! template._NOWARN_OLDSTYLE_HELPERS) {\n        Blaze._warn('Assigning helper with `' + template.viewName + '.' +\n                    name + ' = ...` is deprecated.  Use `' + template.viewName +\n                    '.helpers(...)` instead.');\n      }\n    }\n    if (template[name] != null) {\n      return wrapHelper(bindDataContext(template[name]), tmplInstanceFunc);\n    }\n  }\n\n  return null;\n};\n\nconst wrapHelper = function (f, templateFunc, name = 'template helper') {\n  if (typeof f !== \"function\") {\n    return f;\n  }\n\n  return function (...args) {\n    const self = this;\n\n    return Blaze.Template._withTemplateInstanceFunc(templateFunc, function () {\n      return Blaze._wrapCatchingExceptions(f, name).apply(self, args);\n    });\n  };\n};\n\nfunction _lexicalKeepGoing(currentView) {\n  if (!currentView.parentView) {\n    return undefined;\n  }\n  if (!currentView.__startsNewLexicalScope) {\n    return currentView.parentView;\n  }\n  if (currentView.parentView.__childDoesntStartNewLexicalScope) {\n    return currentView.parentView;\n  }\n\n  // in the case of {{> Template.contentBlock data}} the contentBlock loses the lexical scope of it's parent, wheras {{> Template.contentBlock}} it does not\n  // this is because a #with sits between the include InOuterTemplateScope\n  if (currentView.parentView.name === \"with\" && currentView.parentView.parentView && currentView.parentView.parentView.__childDoesntStartNewLexicalScope) {\n    return currentView.parentView;\n  }\n  return undefined;\n}\n\nfunction _lexicalBindingLookup(view, name) {\n  let currentView = view;\n\n  // walk up the views stopping at a Spacebars.include or Template view that\n  // doesn't have an InOuterTemplateScope view as a parent\n  do {\n    // skip block helpers views\n    // if we found the binding on the scope, return it\n    if (has(currentView._scopeBindings, name)) {\n      return currentView._scopeBindings[name];\n    }\n  } while (currentView = _lexicalKeepGoing(currentView));\n\n  return null;\n}\n\nBlaze._lexicalBindingLookup = function (view, name) {\n  const binding = _lexicalBindingLookup(view, name);\n  return binding && (() => binding.get()?.value);\n};\n\n// templateInstance argument is provided to be available for possible\n// alternative implementations of this function by 3rd party packages.\nBlaze._getTemplate = function (name, templateInstance) {\n  if ((name in Blaze.Template) && (Blaze.Template[name] instanceof Blaze.Template)) {\n    return Blaze.Template[name];\n  }\n  return null;\n};\n\nBlaze._getGlobalHelper = function (name, templateInstance) {\n  if (Blaze._globalHelpers[name] != null) {\n    const printName = `global helper ${name}`;\n    return wrapHelper(bindDataContext(Blaze._globalHelpers[name]), templateInstance, printName);\n  }\n  return null;\n};\n\n// Looks up a name, like \"foo\" or \"..\", as a helper of the\n// current template; the name of a template; a global helper;\n// or a property of the data context.  Called on the View of\n// a template (i.e. a View with a `.template` property,\n// where the helpers are).  Used for the first name in a\n// \"path\" in a template tag, like \"foo\" in `{{foo.bar}}` or\n// \"..\" in `{{frobulate ../blah}}`.\n//\n// Returns a function, a non-function value, or null.  If\n// a function is found, it is bound appropriately.\n//\n// NOTE: This function must not establish any reactive\n// dependencies itself.  If there is any reactivity in the\n// value, lookup should return a function.\nBlaze.View.prototype.lookup = function (name, _options) {\n  const template = this.template;\n  const lookupTemplate = _options && _options.template;\n  let helper;\n  let binding;\n  let boundTmplInstance;\n  let foundTemplate;\n\n  if (this.templateInstance) {\n    boundTmplInstance = Blaze._bind(this.templateInstance, this);\n  }\n\n  // 0. looking up the parent data context with the special \"../\" syntax\n  if (/^\\./.test(name)) {\n    // starts with a dot. must be a series of dots which maps to an\n    // ancestor of the appropriate height.\n    if (!/^(\\.)+$/.test(name))\n      throw new Error(\"id starting with dot must be a series of dots\");\n\n    return Blaze._parentData(name.length - 1, true /*_functionWrapped*/);\n\n  }\n\n  // 1. look up a helper on the current template\n  if (template && ((helper = Blaze._getTemplateHelper(template, name, boundTmplInstance)) != null)) {\n    return helper;\n  }\n\n  // 2. look up a binding by traversing the lexical view hierarchy inside the\n  // current template\n  if (template && (binding = Blaze._lexicalBindingLookup(Blaze.currentView, name)) != null) {\n    return binding;\n  }\n\n  // 3. look up a template by name\n  if (lookupTemplate && ((foundTemplate = Blaze._getTemplate(name, boundTmplInstance)) != null)) {\n    return foundTemplate;\n  }\n\n  // 4. look up a global helper\n  helper = Blaze._getGlobalHelper(name, boundTmplInstance);\n  if (helper != null) {\n    return helper;\n  }\n\n  // 5. look up in a data context\n  return function (...args) {\n    const isCalledAsFunction = (args.length > 0);\n    const data = Blaze.getData();\n    const x = data && data[name];\n    if (! x) {\n      if (lookupTemplate) {\n        throw new Error(\"No such template: \" + name);\n      } else if (isCalledAsFunction) {\n        throw new Error(\"No such function: \" + name);\n      } else if (name.charAt(0) === '@' && ((x === null) ||\n                                            (x === undefined))) {\n        // Throw an error if the user tries to use a `@directive`\n        // that doesn't exist.  We don't implement all directives\n        // from Handlebars, so there's a potential for confusion\n        // if we fail silently.  On the other hand, we want to\n        // throw late in case some app or package wants to provide\n        // a missing directive.\n        throw new Error(\"Unsupported directive: \" + name);\n      }\n    }\n    if (! data) {\n      return null;\n    }\n    if (typeof x !== 'function') {\n      if (isCalledAsFunction) {\n        throw new Error(\"Can't call non-function: \" + x);\n      }\n      return x;\n    }\n    return x.apply(data, args);\n  };\n};\n\n// Implement Spacebars' {{../..}}.\n// @param height {Number} The number of '..'s\nBlaze._parentData = function (height, _functionWrapped) {\n  // If height is null or undefined, we default to 1, the first parent.\n  if (height == null) {\n    height = 1;\n  }\n  let theWith = Blaze.getView('with');\n  for (let i = 0; (i < height) && theWith; i++) {\n    theWith = Blaze.getView(theWith, 'with');\n  }\n\n  if (! theWith)\n    return null;\n  if (_functionWrapped)\n    return function () { return theWith.dataVar.get()?.value; };\n  return theWith.dataVar.get()?.value;\n};\n\n\nBlaze.View.prototype.lookupTemplate = function (name) {\n  return this.lookup(name, {template:true});\n};\n","import isObject from 'lodash.isobject';\nimport isFunction from 'lodash.isfunction';\nimport has from 'lodash.has';\nimport isEmpty from 'lodash.isempty';\n\n// [new] Blaze.Template([viewName], renderFunction)\n//\n// `Blaze.Template` is the class of templates, like `Template.foo` in\n// Meteor, which is `instanceof Template`.\n//\n// `viewKind` is a string that looks like \"Template.foo\" for templates\n// defined by the compiler.\n\n/**\n * @class\n * @summary Constructor for a Template, which is used to construct Views with particular name and content.\n * @locus Client\n * @param {String} [viewName] Optional.  A name for Views constructed by this Template.  See [`view.name`](#view_name).\n * @param {Function} renderFunction A function that returns [*renderable content*](#Renderable-Content).  This function is used as the `renderFunction` for Views constructed by this Template.\n */\nBlaze.Template = function (viewName, renderFunction) {\n  if (! (this instanceof Blaze.Template))\n    // called without `new`\n    return new Blaze.Template(viewName, renderFunction);\n\n  if (typeof viewName === 'function') {\n    // omitted \"viewName\" argument\n    renderFunction = viewName;\n    viewName = '';\n  }\n  if (typeof viewName !== 'string')\n    throw new Error(\"viewName must be a String (or omitted)\");\n  if (typeof renderFunction !== 'function')\n    throw new Error(\"renderFunction must be a function\");\n\n  this.viewName = viewName;\n  this.renderFunction = renderFunction;\n\n  this.__helpers = new HelperMap;\n  this.__eventMaps = [];\n\n  this._callbacks = {\n    created: [],\n    rendered: [],\n    destroyed: []\n  };\n};\nconst Template = Blaze.Template;\n\nconst HelperMap = function () {};\nHelperMap.prototype.get = function (name) {\n  return this[' '+name];\n};\nHelperMap.prototype.set = function (name, helper) {\n  this[' '+name] = helper;\n};\nHelperMap.prototype.has = function (name) {\n  return (typeof this[' '+name] !== 'undefined');\n};\n\n/**\n * @summary Returns true if `value` is a template object like `Template.myTemplate`.\n * @locus Client\n * @param {Any} value The value to test.\n */\nBlaze.isTemplate = function (t) {\n  return (t instanceof Blaze.Template);\n};\n\n/**\n * @name  onCreated\n * @instance\n * @memberOf Template\n * @summary Register a function to be called when an instance of this template is created.\n * @param {Function} callback A function to be added as a callback.\n * @locus Client\n * @importFromPackage templating\n */\nTemplate.prototype.onCreated = function (cb) {\n  this._callbacks.created.push(cb);\n};\n\n/**\n * @name  onRendered\n * @instance\n * @memberOf Template\n * @summary Register a function to be called when an instance of this template is inserted into the DOM.\n * @param {Function} callback A function to be added as a callback.\n * @locus Client\n * @importFromPackage templating\n */\nTemplate.prototype.onRendered = function (cb) {\n  this._callbacks.rendered.push(cb);\n};\n\n/**\n * @name  onDestroyed\n * @instance\n * @memberOf Template\n * @summary Register a function to be called when an instance of this template is removed from the DOM and destroyed.\n * @param {Function} callback A function to be added as a callback.\n * @locus Client\n * @importFromPackage templating\n */\nTemplate.prototype.onDestroyed = function (cb) {\n  this._callbacks.destroyed.push(cb);\n};\n\nTemplate.prototype._getCallbacks = function (which) {\n  const self = this;\n  let callbacks = self[which] ? [self[which]] : [];\n  // Fire all callbacks added with the new API (Template.onRendered())\n  // as well as the old-style callback (e.g. Template.rendered) for\n  // backwards-compatibility.\n  callbacks = callbacks.concat(self._callbacks[which]);\n  return callbacks;\n};\n\nconst fireCallbacks = function (callbacks, template) {\n  Template._withTemplateInstanceFunc(\n    function () { return template; },\n    function () {\n      for (let i = 0, N = callbacks.length; i < N; i++) {\n        callbacks[i].call(template);\n      }\n    });\n};\n\nTemplate.prototype.constructView = function (contentFunc, elseFunc) {\n  const self = this;\n  const view = Blaze.View(self.viewName, self.renderFunction);\n  view.template = self;\n\n  view.templateContentBlock = (\n    contentFunc ? new Template('(contentBlock)', contentFunc) : null);\n  view.templateElseBlock = (\n    elseFunc ? new Template('(elseBlock)', elseFunc) : null);\n\n  if (self.__eventMaps || typeof self.events === 'object') {\n    view._onViewRendered(function () {\n      if (view.renderCount !== 1)\n        return;\n\n      if (! self.__eventMaps.length && typeof self.events === \"object\") {\n        // Provide limited back-compat support for `.events = {...}`\n        // syntax.  Pass `template.events` to the original `.events(...)`\n        // function.  This code must run only once per template, in\n        // order to not bind the handlers more than once, which is\n        // ensured by the fact that we only do this when `__eventMaps`\n        // is falsy, and we cause it to be set now.\n        Template.prototype.events.call(self, self.events);\n      }\n\n      self.__eventMaps.forEach(function (m) {\n        Blaze._addEventMap(view, m, view);\n      });\n    });\n  }\n\n  view._templateInstance = new Blaze.TemplateInstance(view);\n  view.templateInstance = function () {\n    // Update data, firstNode, and lastNode, and return the TemplateInstance\n    // object.\n    const inst = view._templateInstance;\n\n    /**\n     * @instance\n     * @memberOf Blaze.TemplateInstance\n     * @name  data\n     * @summary The data context of this instance's latest invocation.\n     * @locus Client\n     */\n    inst.data = Blaze.getData(view);\n\n    if (view._domrange && !view.isDestroyed) {\n      inst.firstNode = view._domrange.firstNode();\n      inst.lastNode = view._domrange.lastNode();\n    } else {\n      // on 'created' or 'destroyed' callbacks we don't have a DomRange\n      inst.firstNode = null;\n      inst.lastNode = null;\n    }\n\n    return inst;\n  };\n\n  /**\n   * @name  created\n   * @instance\n   * @memberOf Template\n   * @summary Provide a callback when an instance of a template is created.\n   * @locus Client\n   * @deprecated in 1.1\n   */\n  // To avoid situations when new callbacks are added in between view\n  // instantiation and event being fired, decide on all callbacks to fire\n  // immediately and then fire them on the event.\n  const createdCallbacks = self._getCallbacks('created');\n  view.onViewCreated(function () {\n    fireCallbacks(createdCallbacks, view.templateInstance());\n  });\n\n  /**\n   * @name  rendered\n   * @instance\n   * @memberOf Template\n   * @summary Provide a callback when an instance of a template is rendered.\n   * @locus Client\n   * @deprecated in 1.1\n   */\n  const renderedCallbacks = self._getCallbacks('rendered');\n  view.onViewReady(function () {\n    fireCallbacks(renderedCallbacks, view.templateInstance());\n  });\n\n  /**\n   * @name  destroyed\n   * @instance\n   * @memberOf Template\n   * @summary Provide a callback when an instance of a template is destroyed.\n   * @locus Client\n   * @deprecated in 1.1\n   */\n  const destroyedCallbacks = self._getCallbacks('destroyed');\n  view.onViewDestroyed(function () {\n    fireCallbacks(destroyedCallbacks, view.templateInstance());\n  });\n\n  return view;\n};\n\n/**\n * @class\n * @summary The class for template instances\n * @param {Blaze.View} view\n * @instanceName template\n */\nBlaze.TemplateInstance = function (view) {\n  if (! (this instanceof Blaze.TemplateInstance))\n    // called without `new`\n    return new Blaze.TemplateInstance(view);\n\n  if (! (view instanceof Blaze.View))\n    throw new Error(\"View required\");\n\n  view._templateInstance = this;\n\n  /**\n   * @name view\n   * @memberOf Blaze.TemplateInstance\n   * @instance\n   * @summary The [View](../api/blaze.html#Blaze-View) object for this invocation of the template.\n   * @locus Client\n   * @type {Blaze.View}\n   */\n  this.view = view;\n  this.data = null;\n\n  /**\n   * @name firstNode\n   * @memberOf Blaze.TemplateInstance\n   * @instance\n   * @summary The first top-level DOM node in this template instance.\n   * @locus Client\n   * @type {DOMNode}\n   */\n  this.firstNode = null;\n\n  /**\n   * @name lastNode\n   * @memberOf Blaze.TemplateInstance\n   * @instance\n   * @summary The last top-level DOM node in this template instance.\n   * @locus Client\n   * @type {DOMNode}\n   */\n  this.lastNode = null;\n\n  // This dependency is used to identify state transitions in\n  // _subscriptionHandles which could cause the result of\n  // TemplateInstance#subscriptionsReady to change. Basically this is triggered\n  // whenever a new subscription handle is added or when a subscription handle\n  // is removed and they are not ready.\n  this._allSubsReadyDep = new Tracker.Dependency();\n  this._allSubsReady = false;\n\n  this._subscriptionHandles = {};\n};\n\n/**\n * @summary Find all elements matching `selector` in this template instance, and return them as a JQuery object.\n * @locus Client\n * @param {String} selector The CSS selector to match, scoped to the template contents.\n * @returns {DOMNode[]}\n */\nBlaze.TemplateInstance.prototype.$ = function (selector) {\n  const view = this.view;\n  if (! view._domrange)\n    throw new Error(\"Can't use $ on template instance with no DOM\");\n  return view._domrange.$(selector);\n};\n\n/**\n * @summary Find all elements matching `selector` in this template instance.\n * @locus Client\n * @param {String} selector The CSS selector to match, scoped to the template contents.\n * @returns {DOMElement[]}\n */\nBlaze.TemplateInstance.prototype.findAll = function (selector) {\n  return Array.prototype.slice.call(this.$(selector));\n};\n\n/**\n * @summary Find one element matching `selector` in this template instance.\n * @locus Client\n * @param {String} selector The CSS selector to match, scoped to the template contents.\n * @returns {DOMElement}\n */\nBlaze.TemplateInstance.prototype.find = function (selector) {\n  const result = this.$(selector);\n  return result[0] || null;\n};\n\n/**\n * @summary A version of [Tracker.autorun](https://docs.meteor.com/api/tracker.html#Tracker-autorun) that is stopped when the template is destroyed.\n * @locus Client\n * @param {Function} runFunc The function to run. It receives one argument: a Tracker.Computation object.\n */\nBlaze.TemplateInstance.prototype.autorun = function (f) {\n  return this.view.autorun(f);\n};\n\n/**\n * @summary A version of [Meteor.subscribe](https://docs.meteor.com/api/pubsub.html#Meteor-subscribe) that is stopped\n * when the template is destroyed.\n * @return {SubscriptionHandle} The subscription handle to the newly made\n * subscription. Call `handle.stop()` to manually stop the subscription, or\n * `handle.ready()` to find out if this particular subscription has loaded all\n * of its inital data.\n * @locus Client\n * @param {String} name Name of the subscription.  Matches the name of the\n * server's `publish()` call.\n * @param {Any} [arg1,arg2...] Optional arguments passed to publisher function\n * on server.\n * @param {Function|Object} [options] If a function is passed instead of an\n * object, it is interpreted as an `onReady` callback.\n * @param {Function} [options.onReady] Passed to [`Meteor.subscribe`](https://docs.meteor.com/api/pubsub.html#Meteor-subscribe).\n * @param {Function} [options.onStop] Passed to [`Meteor.subscribe`](https://docs.meteor.com/api/pubsub.html#Meteor-subscribe).\n * @param {DDP.Connection} [options.connection] The connection on which to make the\n * subscription.\n */\nBlaze.TemplateInstance.prototype.subscribe = function (...args) {\n  const self = this;\n\n  const subHandles = self._subscriptionHandles;\n\n  // Duplicate logic from Meteor.subscribe\n  let options = {};\n  if (args.length) {\n    const lastParam = args[args.length - 1];\n\n    // Match pattern to check if the last arg is an options argument\n    const lastParamOptionsPattern = {\n      onReady: Match.Optional(Function),\n      // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\n      // onStop with an error callback instead.\n      onError: Match.Optional(Function),\n      onStop: Match.Optional(Function),\n      connection: Match.Optional(Match.Any)\n    };\n\n    if (isFunction(lastParam)) {\n      options.onReady = args.pop();\n    } else if (lastParam && ! isEmpty(lastParam) && Match.test(lastParam, lastParamOptionsPattern)) {\n      options = args.pop();\n    }\n  }\n\n  let subHandle;\n  const oldStopped = options.onStop;\n  options.onStop = function (error) {\n    // When the subscription is stopped, remove it from the set of tracked\n    // subscriptions to avoid this list growing without bound\n    delete subHandles[subHandle.subscriptionId];\n\n    // Removing a subscription can only change the result of subscriptionsReady\n    // if we are not ready (that subscription could be the one blocking us being\n    // ready).\n    if (! self._allSubsReady) {\n      self._allSubsReadyDep.changed();\n    }\n\n    if (oldStopped) {\n      oldStopped(error);\n    }\n  };\n\n  const { onReady, onError, onStop, connection } = options;\n  const callbacks = { onReady, onError, onStop };\n\n  // The callbacks are passed as the last item in the arguments array passed to\n  // View#subscribe\n  args.push(callbacks);\n\n  // View#subscribe takes the connection as one of the options in the last\n  // argument\n  subHandle = self.view.subscribe.call(self.view, args, {\n    connection: connection\n  });\n\n  if (!has(subHandles, subHandle.subscriptionId)) {\n    subHandles[subHandle.subscriptionId] = subHandle;\n\n    // Adding a new subscription will always cause us to transition from ready\n    // to not ready, but if we are already not ready then this can't make us\n    // ready.\n    if (self._allSubsReady) {\n      self._allSubsReadyDep.changed();\n    }\n  }\n\n  return subHandle;\n};\n\n/**\n * @summary A reactive function that returns true when all of the subscriptions\n * called with [this.subscribe](#TemplateInstance-subscribe) are ready.\n * @return {Boolean} True if all subscriptions on this template instance are\n * ready.\n */\nBlaze.TemplateInstance.prototype.subscriptionsReady = function () {\n  this._allSubsReadyDep.depend();\n  this._allSubsReady = Object.values(this._subscriptionHandles).every((handle) => {\n    return handle.ready();\n  });\n\n  return this._allSubsReady;\n};\n\n/**\n * @summary Specify template helpers available to this template.\n * @locus Client\n * @param {Object} helpers Dictionary of helper functions by name.\n * @importFromPackage templating\n */\nTemplate.prototype.helpers = function (dict) {\n  if (!isObject(dict)) {\n    throw new Error(\"Helpers dictionary has to be an object\");\n  }\n\n  for (let k in dict) this.__helpers.set(k, dict[k]);\n};\n\nconst canUseGetters = (function () {\n  if (Object.defineProperty) {\n    let obj = {};\n    try {\n      Object.defineProperty(obj, \"self\", {\n        get: function () { return obj; }\n      });\n    } catch (e) {\n      return false;\n    }\n    return obj.self === obj;\n  }\n  return false;\n})();\n\nif (canUseGetters) {\n  // Like Blaze.currentView but for the template instance. A function\n  // rather than a value so that not all helpers are implicitly dependent\n  // on the current template instance's `data` property, which would make\n  // them dependent on the data context of the template inclusion.\n  let currentTemplateInstanceFunc = null;\n\n  // If getters are supported, define this property with a getter function\n  // to make it effectively read-only, and to work around this bizarre JSC\n  // bug: https://github.com/meteor/meteor/issues/9926\n  Object.defineProperty(Template, \"_currentTemplateInstanceFunc\", {\n    get: function () {\n      return currentTemplateInstanceFunc;\n    }\n  });\n\n  Template._withTemplateInstanceFunc = function (templateInstanceFunc, func) {\n    if (typeof func !== 'function') {\n      throw new Error(\"Expected function, got: \" + func);\n    }\n    const oldTmplInstanceFunc = currentTemplateInstanceFunc;\n    try {\n      currentTemplateInstanceFunc = templateInstanceFunc;\n      return func();\n    } finally {\n      currentTemplateInstanceFunc = oldTmplInstanceFunc;\n    }\n  };\n} else {\n  // If getters are not supported, just use a normal property.\n  Template._currentTemplateInstanceFunc = null;\n\n  Template._withTemplateInstanceFunc = function (templateInstanceFunc, func) {\n    if (typeof func !== 'function') {\n      throw new Error(\"Expected function, got: \" + func);\n    }\n    const oldTmplInstanceFunc = Template._currentTemplateInstanceFunc;\n    try {\n      Template._currentTemplateInstanceFunc = templateInstanceFunc;\n      return func();\n    } finally {\n      Template._currentTemplateInstanceFunc = oldTmplInstanceFunc;\n    }\n  };\n}\n\n/**\n * @summary Specify event handlers for this template.\n * @locus Client\n * @param {EventMap} eventMap Event handlers to associate with this template.\n * @importFromPackage templating\n */\nTemplate.prototype.events = function (eventMap) {\n  if (!isObject(eventMap)) {\n    throw new Error(\"Event map has to be an object\");\n  }\n\n  const template = this;\n  let eventMap2 = {};\n  for (let k in eventMap) {\n    eventMap2[k] = (function (k, v) {\n      return function (event /*, ...*/) {\n        const view = this; // passed by EventAugmenter\n        const args = Array.prototype.slice.call(arguments);\n        // Exiting the current computation to avoid creating unnecessary\n        // and unexpected reactive dependencies with Templates data\n        // or any other reactive dependencies defined in event handlers\n        return Tracker.nonreactive(function () {\n          let data = Blaze.getData(event.currentTarget);\n          if (data == null) data = {};\n          const tmplInstanceFunc = Blaze._bind(view.templateInstance, view);\n          args.splice(1, 0, tmplInstanceFunc());\n          return Template._withTemplateInstanceFunc(tmplInstanceFunc, function () {\n            return v.apply(data, args);\n          });\n        });\n      };\n    })(k, eventMap[k]);\n  }\n\n  template.__eventMaps.push(eventMap2);\n};\n\n/**\n * @function\n * @name instance\n * @memberOf Template\n * @summary The [template instance](#Template-instances) corresponding to the current template helper, event handler, callback, or autorun.  If there isn't one, `null`.\n * @locus Client\n * @returns {Blaze.TemplateInstance}\n * @importFromPackage templating\n */\nTemplate.instance = function () {\n  return Template._currentTemplateInstanceFunc\n    && Template._currentTemplateInstanceFunc();\n};\n\n// Note: Template.currentData() is documented to take zero arguments,\n// while Blaze.getData takes up to one.\n\n/**\n * @summary\n *\n * - Inside an `onCreated`, `onRendered`, or `onDestroyed` callback, returns\n * the data context of the template.\n * - Inside an event handler, returns the data context of the template on which\n * this event handler was defined.\n * - Inside a helper, returns the data context of the DOM node where the helper\n * was used.\n *\n * Establishes a reactive dependency on the result.\n * @locus Client\n * @function\n * @importFromPackage templating\n */\nTemplate.currentData = Blaze.getData;\n\n/**\n * @summary Accesses other data contexts that enclose the current data context.\n * @locus Client\n * @function\n * @param {Integer} [numLevels] The number of levels beyond the current data context to look. Defaults to 1.\n * @importFromPackage templating\n */\nTemplate.parentData = Blaze._parentData;\n\n/**\n * @summary Defines a [helper function](#Template-helpers) which can be used from all templates.\n * @locus Client\n * @function\n * @param {String} name The name of the helper function you are defining.\n * @param {Function} function The helper function itself.\n * @importFromPackage templating\n */\nTemplate.registerHelper = Blaze.registerHelper;\n\n/**\n * @summary Removes a global [helper function](#Template-helpers).\n * @locus Client\n * @function\n * @param {String} name The name of the helper function you are defining.\n * @importFromPackage templating\n */\nTemplate.deregisterHelper = Blaze.deregisterHelper;\n","UI = Blaze;\n\nBlaze.ReactiveVar = ReactiveVar;\nUI._templateInstance = Blaze.Template.instance;\n\nHandlebars = {};\nHandlebars.registerHelper = Blaze.registerHelper;\n\nHandlebars._escape = Blaze._escape;\n\n// Return these from {{...}} helpers to achieve the same as returning\n// strings from {{{...}}} helpers\nHandlebars.SafeString = function(string) {\n  this.string = string;\n};\nHandlebars.SafeString.prototype.toString = function() {\n  return this.string.toString();\n};\n"]}}]