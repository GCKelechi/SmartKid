{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/gckelechi/SmartKid/packages/blaze/view.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/blaze/view.js","filename":"/home/gckelechi/SmartKid/packages/blaze/view.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/gckelechi/SmartKid","root":"/home/gckelechi/SmartKid","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true,"topLevelAwait":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/home/gckelechi/SmartKid/packages/blaze/view.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/blaze/view.js"}},"code":"!module.wrapAsync(async function (module, __reifyWaitForDeps__, __reify_async_result__) {\n  \"use strict\";\n  try {\n    let HTML;\n    module.link(\"meteor/htmljs\", {\n      HTML(v) {\n        HTML = v;\n      }\n    }, 0);\n    if (__reifyWaitForDeps__()) (await __reifyWaitForDeps__())();\n    /**\n     * A binding is either `undefined` (pending), `{ error }` (rejected), or\n     * `{ value }` (resolved). Synchronous values are immediately resolved (i.e.,\n     * `{ value }` is used). The other states are reserved for asynchronous bindings\n     * (i.e., values wrapped with `Promise`s).\n     * @typedef {{ error: unknown } | { value: unknown } | undefined} Binding\n     */\n\n    /**\n     * @class\n     * @summary Constructor for a View, which represents a reactive region of DOM.\n     * @locus Client\n     * @param {String} [name] Optional.  A name for this type of View.  See [`view.name`](#view_name).\n     * @param {Function} renderFunction A function that returns [*renderable content*](#Renderable-Content).  In this function, `this` is bound to the View.\n     */\n    Blaze.View = function (name, render) {\n      if (!(this instanceof Blaze.View))\n        // called without `new`\n        return new Blaze.View(name, render);\n      if (typeof name === 'function') {\n        // omitted \"name\" argument\n        render = name;\n        name = '';\n      }\n      this.name = name;\n      this._render = render;\n      this._callbacks = {\n        created: null,\n        rendered: null,\n        destroyed: null\n      };\n\n      // Setting all properties here is good for readability,\n      // and also may help Chrome optimize the code by keeping\n      // the View object from changing shape too much.\n      this.isCreated = false;\n      this._isCreatedForExpansion = false;\n      this.isRendered = false;\n      this._isAttached = false;\n      this.isDestroyed = false;\n      this._isInRender = false;\n      this.parentView = null;\n      this._domrange = null;\n      // This flag is normally set to false except for the cases when view's parent\n      // was generated as part of expanding some syntactic sugar expressions or\n      // methods.\n      // Ex.: Blaze.renderWithData is an equivalent to creating a view with regular\n      // Blaze.render and wrapping it into {{#with data}}{{/with}} view. Since the\n      // users don't know anything about these generated parent views, Blaze needs\n      // this information to be available on views to make smarter decisions. For\n      // example: removing the generated parent view with the view on Blaze.remove.\n      this._hasGeneratedParent = false;\n      // Bindings accessible to children views (via view.lookup('name')) within the\n      // closest template view.\n      /** @type {Record<string, ReactiveVar<Binding>>} */\n      this._scopeBindings = {};\n      this.renderCount = 0;\n    };\n    Blaze.View.prototype._render = function () {\n      return null;\n    };\n    Blaze.View.prototype.onViewCreated = function (cb) {\n      this._callbacks.created = this._callbacks.created || [];\n      this._callbacks.created.push(cb);\n    };\n    Blaze.View.prototype._onViewRendered = function (cb) {\n      this._callbacks.rendered = this._callbacks.rendered || [];\n      this._callbacks.rendered.push(cb);\n    };\n    Blaze.View.prototype.onViewReady = function (cb) {\n      const self = this;\n      const fire = function () {\n        Tracker.afterFlush(function () {\n          if (!self.isDestroyed) {\n            Blaze._withCurrentView(self, function () {\n              cb.call(self);\n            });\n          }\n        });\n      };\n      self._onViewRendered(function onViewRendered() {\n        if (self.isDestroyed) return;\n        if (!self._domrange.attached) self._domrange.onAttached(fire);else fire();\n      });\n    };\n    Blaze.View.prototype.onViewDestroyed = function (cb) {\n      this._callbacks.destroyed = this._callbacks.destroyed || [];\n      this._callbacks.destroyed.push(cb);\n    };\n    Blaze.View.prototype.removeViewDestroyedListener = function (cb) {\n      const destroyed = this._callbacks.destroyed;\n      if (!destroyed) return;\n      const index = destroyed.lastIndexOf(cb);\n      if (index !== -1) {\n        // XXX You'd think the right thing to do would be splice, but _fireCallbacks\n        // gets sad if you remove callbacks while iterating over the list.  Should\n        // change this to use callback-hook or EventEmitter or something else that\n        // properly supports removal.\n        destroyed[index] = null;\n      }\n    };\n\n    /// View#autorun(func)\n    ///\n    /// Sets up a Tracker autorun that is \"scoped\" to this View in two\n    /// important ways: 1) Blaze.currentView is automatically set\n    /// on every re-run, and 2) the autorun is stopped when the\n    /// View is destroyed.  As with Tracker.autorun, the first run of\n    /// the function is immediate, and a Computation object that can\n    /// be used to stop the autorun is returned.\n    ///\n    /// View#autorun is meant to be called from View callbacks like\n    /// onViewCreated, or from outside the rendering process.  It may not\n    /// be called before the onViewCreated callbacks are fired (too early),\n    /// or from a render() method (too confusing).\n    ///\n    /// Typically, autoruns that update the state\n    /// of the View (as in Blaze.With) should be started from an onViewCreated\n    /// callback.  Autoruns that update the DOM should be started\n    /// from either onViewCreated (guarded against the absence of\n    /// view._domrange), or onViewReady.\n    Blaze.View.prototype.autorun = function (f, _inViewScope, displayName) {\n      const self = this;\n\n      // The restrictions on when View#autorun can be called are in order\n      // to avoid bad patterns, like creating a Blaze.View and immediately\n      // calling autorun on it.  A freshly created View is not ready to\n      // have logic run on it; it doesn't have a parentView, for example.\n      // It's when the View is materialized or expanded that the onViewCreated\n      // handlers are fired and the View starts up.\n      //\n      // Letting the render() method call `this.autorun()` is problematic\n      // because of re-render.  The best we can do is to stop the old\n      // autorun and start a new one for each render, but that's a pattern\n      // we try to avoid internally because it leads to helpers being\n      // called extra times, in the case where the autorun causes the\n      // view to re-render (and thus the autorun to be torn down and a\n      // new one established).\n      //\n      // We could lift these restrictions in various ways.  One interesting\n      // idea is to allow you to call `view.autorun` after instantiating\n      // `view`, and automatically wrap it in `view.onViewCreated`, deferring\n      // the autorun so that it starts at an appropriate time.  However,\n      // then we can't return the Computation object to the caller, because\n      // it doesn't exist yet.\n      if (!self.isCreated) {\n        throw new Error(\"View#autorun must be called from the created callback at the earliest\");\n      }\n      if (this._isInRender) {\n        throw new Error(\"Can't call View#autorun from inside render(); try calling it from the created or rendered callback\");\n      }\n      const templateInstanceFunc = Blaze.Template._currentTemplateInstanceFunc;\n      const func = function viewAutorun(c) {\n        return Blaze._withCurrentView(_inViewScope || self, function () {\n          return Blaze.Template._withTemplateInstanceFunc(templateInstanceFunc, function () {\n            return f.call(self, c);\n          });\n        });\n      };\n\n      // Give the autorun function a better name for debugging and profiling.\n      // The `displayName` property is not part of the spec but browsers like Chrome\n      // and Firefox prefer it in debuggers over the name function was declared by.\n      func.displayName = (self.name || 'anonymous') + ':' + (displayName || 'anonymous');\n      const comp = Tracker.autorun(func);\n      const stopComputation = function () {\n        comp.stop();\n      };\n      self.onViewDestroyed(stopComputation);\n      comp.onStop(function () {\n        self.removeViewDestroyedListener(stopComputation);\n      });\n      return comp;\n    };\n    Blaze.View.prototype._errorIfShouldntCallSubscribe = function () {\n      const self = this;\n      if (!self.isCreated) {\n        throw new Error(\"View#subscribe must be called from the created callback at the earliest\");\n      }\n      if (self._isInRender) {\n        throw new Error(\"Can't call View#subscribe from inside render(); try calling it from the created or rendered callback\");\n      }\n      if (self.isDestroyed) {\n        throw new Error(\"Can't call View#subscribe from inside the destroyed callback, try calling it inside created or rendered.\");\n      }\n    };\n\n    /**\n     * Just like Blaze.View#autorun, but with Meteor.subscribe instead of\n     * Tracker.autorun. Stop the subscription when the view is destroyed.\n     * @return {SubscriptionHandle} A handle to the subscription so that you can\n     * see if it is ready, or stop it manually\n     */\n    Blaze.View.prototype.subscribe = function (args, options) {\n      const self = this;\n      options = options || {};\n      self._errorIfShouldntCallSubscribe();\n      let subHandle;\n      if (options.connection) {\n        subHandle = options.connection.subscribe.apply(options.connection, args);\n      } else {\n        subHandle = Meteor.subscribe.apply(Meteor, args);\n      }\n      self.onViewDestroyed(function () {\n        subHandle.stop();\n      });\n      return subHandle;\n    };\n    Blaze.View.prototype.firstNode = function () {\n      if (!this._isAttached) throw new Error(\"View must be attached before accessing its DOM\");\n      return this._domrange.firstNode();\n    };\n    Blaze.View.prototype.lastNode = function () {\n      if (!this._isAttached) throw new Error(\"View must be attached before accessing its DOM\");\n      return this._domrange.lastNode();\n    };\n    Blaze._fireCallbacks = function (view, which) {\n      Blaze._withCurrentView(view, function () {\n        Tracker.nonreactive(function fireCallbacks() {\n          const cbs = view._callbacks[which];\n          for (let i = 0, N = cbs && cbs.length; i < N; i++) cbs[i] && cbs[i].call(view);\n        });\n      });\n    };\n    Blaze._createView = function (view, parentView, forExpansion) {\n      if (view.isCreated) throw new Error(\"Can't render the same View twice\");\n      view.parentView = parentView || null;\n      view.isCreated = true;\n      if (forExpansion) view._isCreatedForExpansion = true;\n      Blaze._fireCallbacks(view, 'created');\n    };\n    const doFirstRender = function (view, initialContent) {\n      const domrange = new Blaze._DOMRange(initialContent);\n      view._domrange = domrange;\n      domrange.view = view;\n      view.isRendered = true;\n      Blaze._fireCallbacks(view, 'rendered');\n      let teardownHook = null;\n      domrange.onAttached(function attached(range, element) {\n        view._isAttached = true;\n        teardownHook = Blaze._DOMBackend.Teardown.onElementTeardown(element, function teardown() {\n          Blaze._destroyView(view, true /* _skipNodes */);\n        });\n      });\n\n      // tear down the teardown hook\n      view.onViewDestroyed(function () {\n        if (teardownHook) teardownHook.stop();\n        teardownHook = null;\n      });\n      return domrange;\n    };\n\n    // Take an uncreated View `view` and create and render it to DOM,\n    // setting up the autorun that updates the View.  Returns a new\n    // DOMRange, which has been associated with the View.\n    //\n    // The private arguments `_workStack` and `_intoArray` are passed in\n    // by Blaze._materializeDOM and are only present for recursive calls\n    // (when there is some other _materializeView on the stack).  If\n    // provided, then we avoid the mutual recursion of calling back into\n    // Blaze._materializeDOM so that deep View hierarchies don't blow the\n    // stack.  Instead, we push tasks onto workStack for the initial\n    // rendering and subsequent setup of the View, and they are done after\n    // we return.  When there is a _workStack, we do not return the new\n    // DOMRange, but instead push it into _intoArray from a _workStack\n    // task.\n    Blaze._materializeView = function (view, parentView, _workStack, _intoArray) {\n      Blaze._createView(view, parentView);\n      let domrange;\n      let lastHtmljs;\n      // We don't expect to be called in a Computation, but just in case,\n      // wrap in Tracker.nonreactive.\n      Tracker.nonreactive(function () {\n        view.autorun(function doRender(c) {\n          // `view.autorun` sets the current view.\n          view.renderCount = view.renderCount + 1;\n          view._isInRender = true;\n          // Any dependencies that should invalidate this Computation come\n          // from this line:\n          const htmljs = view._render();\n          view._isInRender = false;\n          if (!c.firstRun && !Blaze._isContentEqual(lastHtmljs, htmljs)) {\n            Tracker.nonreactive(function doMaterialize() {\n              // re-render\n              const rangesAndNodes = Blaze._materializeDOM(htmljs, [], view);\n              domrange.setMembers(rangesAndNodes);\n              Blaze._fireCallbacks(view, 'rendered');\n            });\n          }\n          lastHtmljs = htmljs;\n\n          // Causes any nested views to stop immediately, not when we call\n          // `setMembers` the next time around the autorun.  Otherwise,\n          // helpers in the DOM tree to be replaced might be scheduled\n          // to re-run before we have a chance to stop them.\n          Tracker.onInvalidate(function () {\n            if (domrange) {\n              domrange.destroyMembers();\n            }\n          });\n        }, undefined, 'materialize');\n\n        // first render.  lastHtmljs is the first htmljs.\n        let initialContents;\n        if (!_workStack) {\n          initialContents = Blaze._materializeDOM(lastHtmljs, [], view);\n          domrange = doFirstRender(view, initialContents);\n          initialContents = null; // help GC because we close over this scope a lot\n        } else {\n          // We're being called from Blaze._materializeDOM, so to avoid\n          // recursion and save stack space, provide a description of the\n          // work to be done instead of doing it.  Tasks pushed onto\n          // _workStack will be done in LIFO order after we return.\n          // The work will still be done within a Tracker.nonreactive,\n          // because it will be done by some call to Blaze._materializeDOM\n          // (which is always called in a Tracker.nonreactive).\n          initialContents = [];\n          // push this function first so that it happens last\n          _workStack.push(function () {\n            domrange = doFirstRender(view, initialContents);\n            initialContents = null; // help GC because of all the closures here\n            _intoArray.push(domrange);\n          });\n          // now push the task that calculates initialContents\n          _workStack.push(Blaze._bind(Blaze._materializeDOM, null, lastHtmljs, initialContents, view, _workStack));\n        }\n      });\n      if (!_workStack) {\n        return domrange;\n      } else {\n        return null;\n      }\n    };\n\n    // Expands a View to HTMLjs, calling `render` recursively on all\n    // Views and evaluating any dynamic attributes.  Calls the `created`\n    // callback, but not the `materialized` or `rendered` callbacks.\n    // Destroys the view immediately, unless called in a Tracker Computation,\n    // in which case the view will be destroyed when the Computation is\n    // invalidated.  If called in a Tracker Computation, the result is a\n    // reactive string; that is, the Computation will be invalidated\n    // if any changes are made to the view or subviews that might affect\n    // the HTML.\n    Blaze._expandView = function (view, parentView) {\n      Blaze._createView(view, parentView, true /*forExpansion*/);\n      view._isInRender = true;\n      const htmljs = Blaze._withCurrentView(view, function () {\n        return view._render();\n      });\n      view._isInRender = false;\n      const result = Blaze._expand(htmljs, view);\n      if (Tracker.active) {\n        Tracker.onInvalidate(function () {\n          Blaze._destroyView(view);\n        });\n      } else {\n        Blaze._destroyView(view);\n      }\n      return result;\n    };\n\n    // Options: `parentView`\n    Blaze._HTMLJSExpander = HTML.TransformingVisitor.extend();\n    Blaze._HTMLJSExpander.def({\n      visitObject: function (x) {\n        if (x instanceof Blaze.Template) x = x.constructView();\n        if (x instanceof Blaze.View) return Blaze._expandView(x, this.parentView);\n\n        // this will throw an error; other objects are not allowed!\n        return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n      },\n      visitAttributes: function (attrs) {\n        // expand dynamic attributes\n        if (typeof attrs === 'function') attrs = Blaze._withCurrentView(this.parentView, attrs);\n\n        // call super (e.g. for case where `attrs` is an array)\n        return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\n      },\n      visitAttribute: function (name, value, tag) {\n        // expand attribute values that are functions.  Any attribute value\n        // that contains Views must be wrapped in a function.\n        if (typeof value === 'function') value = Blaze._withCurrentView(this.parentView, value);\n        return HTML.TransformingVisitor.prototype.visitAttribute.call(this, name, value, tag);\n      }\n    });\n\n    // Return Blaze.currentView, but only if it is being rendered\n    // (i.e. we are in its render() method).\n    const currentViewIfRendering = function () {\n      const view = Blaze.currentView;\n      return view && view._isInRender ? view : null;\n    };\n    Blaze._expand = function (htmljs, parentView) {\n      parentView = parentView || currentViewIfRendering();\n      return new Blaze._HTMLJSExpander({\n        parentView: parentView\n      }).visit(htmljs);\n    };\n    Blaze._expandAttributes = function (attrs, parentView) {\n      parentView = parentView || currentViewIfRendering();\n      const expanded = new Blaze._HTMLJSExpander({\n        parentView: parentView\n      }).visitAttributes(attrs);\n      return expanded || {};\n    };\n    Blaze._destroyView = function (view, _skipNodes) {\n      if (view.isDestroyed) return;\n      view.isDestroyed = true;\n\n      // Destroy views and elements recursively.  If _skipNodes,\n      // only recurse up to views, not elements, for the case where\n      // the backend (jQuery) is recursing over the elements already.\n\n      if (view._domrange) view._domrange.destroyMembers(_skipNodes);\n\n      // XXX: fire callbacks after potential members are destroyed\n      // otherwise it's tracker.flush will cause the above line will\n      // not be called and their views won't be destroyed\n      // Involved issues: DOMRange \"Must be attached\" error, mem leak\n\n      Blaze._fireCallbacks(view, 'destroyed');\n    };\n    Blaze._destroyNode = function (node) {\n      if (node.nodeType === 1) Blaze._DOMBackend.Teardown.tearDownElement(node);\n    };\n\n    // Are the HTMLjs entities `a` and `b` the same?  We could be\n    // more elaborate here but the point is to catch the most basic\n    // cases.\n    Blaze._isContentEqual = function (a, b) {\n      if (a instanceof HTML.Raw) {\n        return b instanceof HTML.Raw && a.value === b.value;\n      } else if (a == null) {\n        return b == null;\n      } else {\n        return a === b && (typeof a === 'number' || typeof a === 'boolean' || typeof a === 'string');\n      }\n    };\n\n    /**\n     * @summary The View corresponding to the current template helper, event handler, callback, or autorun.  If there isn't one, `null`.\n     * @locus Client\n     * @type {Blaze.View}\n     */\n    Blaze.currentView = null;\n\n    /**\n     * @template T\n     * @param {Blaze.View} view\n     * @param {function(): T} func\n     * @returns {T}\n     */\n    Blaze._withCurrentView = function (view, func) {\n      const oldView = Blaze.currentView;\n      try {\n        Blaze.currentView = view;\n        return func();\n      } finally {\n        Blaze.currentView = oldView;\n      }\n    };\n\n    // Blaze.render publicly takes a View or a Template.\n    // Privately, it takes any HTMLJS (extended with Views and Templates)\n    // except null or undefined, or a function that returns any extended\n    // HTMLJS.\n    const checkRenderContent = function (content) {\n      if (content === null) throw new Error(\"Can't render null\");\n      if (typeof content === 'undefined') throw new Error(\"Can't render undefined\");\n      if (content instanceof Blaze.View || content instanceof Blaze.Template || typeof content === 'function') return;\n      try {\n        // Throw if content doesn't look like HTMLJS at the top level\n        // (i.e. verify that this is an HTML.Tag, or an array,\n        // or a primitive, etc.)\n        new HTML.Visitor().visit(content);\n      } catch (e) {\n        // Make error message suitable for public API\n        throw new Error(\"Expected Template or View\");\n      }\n    };\n\n    // For Blaze.render and Blaze.toHTML, take content and\n    // wrap it in a View, unless it's a single View or\n    // Template already.\n    const contentAsView = function (content) {\n      checkRenderContent(content);\n      if (content instanceof Blaze.Template) {\n        return content.constructView();\n      } else if (content instanceof Blaze.View) {\n        return content;\n      } else {\n        let func = content;\n        if (typeof func !== 'function') {\n          func = function () {\n            return content;\n          };\n        }\n        return Blaze.View('render', func);\n      }\n    };\n\n    // For Blaze.renderWithData and Blaze.toHTMLWithData, wrap content\n    // in a function, if necessary, so it can be a content arg to\n    // a Blaze.With.\n    const contentAsFunc = function (content) {\n      checkRenderContent(content);\n      if (typeof content !== 'function') {\n        return function () {\n          return content;\n        };\n      } else {\n        return content;\n      }\n    };\n    Blaze.__rootViews = [];\n\n    /**\n     * @summary Renders a template or View to DOM nodes and inserts it into the DOM, returning a rendered [View](#Blaze-View) which can be passed to [`Blaze.remove`](#Blaze-remove).\n     * @locus Client\n     * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.  If a template, a View object is [constructed](#template_constructview).  If a View, it must be an unrendered View, which becomes a rendered View and is returned.\n     * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n     * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n     * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n     */\n    Blaze.render = function (content, parentElement, nextNode, parentView) {\n      if (!parentElement) {\n        Blaze._warn(\"Blaze.render without a parent element is deprecated. \" + \"You must specify where to insert the rendered content.\");\n      }\n      if (nextNode instanceof Blaze.View) {\n        // handle omitted nextNode\n        parentView = nextNode;\n        nextNode = null;\n      }\n\n      // parentElement must be a DOM node. in particular, can't be the\n      // result of a call to `$`. Can't check if `parentElement instanceof\n      // Node` since 'Node' is undefined in IE8.\n      if (parentElement && typeof parentElement.nodeType !== 'number') throw new Error(\"'parentElement' must be a DOM node\");\n      if (nextNode && typeof nextNode.nodeType !== 'number')\n        // 'nextNode' is optional\n        throw new Error(\"'nextNode' must be a DOM node\");\n      parentView = parentView || currentViewIfRendering();\n      const view = contentAsView(content);\n\n      // TODO: this is only needed in development\n      if (!parentView) {\n        view.onViewCreated(function () {\n          Blaze.__rootViews.push(view);\n        });\n        view.onViewDestroyed(function () {\n          let index = Blaze.__rootViews.indexOf(view);\n          if (index > -1) {\n            Blaze.__rootViews.splice(index, 1);\n          }\n        });\n      }\n      Blaze._materializeView(view, parentView);\n      if (parentElement) {\n        view._domrange.attach(parentElement, nextNode);\n      }\n      return view;\n    };\n    Blaze.insert = function (view, parentElement, nextNode) {\n      Blaze._warn(\"Blaze.insert has been deprecated.  Specify where to insert the \" + \"rendered content in the call to Blaze.render.\");\n      if (!(view && view._domrange instanceof Blaze._DOMRange)) throw new Error(\"Expected template rendered with Blaze.render\");\n      view._domrange.attach(parentElement, nextNode);\n    };\n\n    /**\n     * @summary Renders a template or View to DOM nodes with a data context.  Otherwise identical to `Blaze.render`.\n     * @locus Client\n     * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.\n     * @param {Object|Function} data The data context to use, or a function returning a data context.  If a function is provided, it will be reactively re-run.\n     * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n     * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n     * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n     */\n    Blaze.renderWithData = function (content, data, parentElement, nextNode, parentView) {\n      // We defer the handling of optional arguments to Blaze.render.  At this point,\n      // `nextNode` may actually be `parentView`.\n      return Blaze.render(Blaze._TemplateWith(data, contentAsFunc(content)), parentElement, nextNode, parentView);\n    };\n\n    /**\n     * @summary Removes a rendered View from the DOM, stopping all reactive updates and event listeners on it. Also destroys the Blaze.Template instance associated with the view.\n     * @locus Client\n     * @param {Blaze.View} renderedView The return value from `Blaze.render` or `Blaze.renderWithData`, or the `view` property of a Blaze.Template instance. Calling `Blaze.remove(Template.instance().view)` from within a template event handler will destroy the view as well as that template and trigger the template's `onDestroyed` handlers.\n     */\n    Blaze.remove = function (view) {\n      if (!(view && view._domrange instanceof Blaze._DOMRange)) throw new Error(\"Expected template rendered with Blaze.render\");\n      while (view) {\n        if (!view.isDestroyed) {\n          const range = view._domrange;\n          range.destroy();\n          if (range.attached && !range.parentRange) {\n            range.detach();\n          }\n        }\n        view = view._hasGeneratedParent && view.parentView;\n      }\n    };\n\n    /**\n     * @summary Renders a template or View to a string of HTML.\n     * @locus Client\n     * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n     */\n    Blaze.toHTML = function (content, parentView) {\n      parentView = parentView || currentViewIfRendering();\n      return HTML.toHTML(Blaze._expandView(contentAsView(content), parentView));\n    };\n\n    /**\n     * @summary Renders a template or View to HTML with a data context.  Otherwise identical to `Blaze.toHTML`.\n     * @locus Client\n     * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n     * @param {Object|Function} data The data context to use, or a function returning a data context.\n     */\n    Blaze.toHTMLWithData = function (content, data, parentView) {\n      parentView = parentView || currentViewIfRendering();\n      return HTML.toHTML(Blaze._expandView(Blaze._TemplateWith(data, contentAsFunc(content)), parentView));\n    };\n    Blaze._toText = function (htmljs, parentView, textMode) {\n      if (typeof htmljs === 'function') throw new Error(\"Blaze._toText doesn't take a function, just HTMLjs\");\n      if (parentView != null && !(parentView instanceof Blaze.View)) {\n        // omitted parentView argument\n        textMode = parentView;\n        parentView = null;\n      }\n      parentView = parentView || currentViewIfRendering();\n      if (!textMode) throw new Error(\"textMode required\");\n      if (!(textMode === HTML.TEXTMODE.STRING || textMode === HTML.TEXTMODE.RCDATA || textMode === HTML.TEXTMODE.ATTRIBUTE)) throw new Error(\"Unknown textMode: \" + textMode);\n      return HTML.toText(Blaze._expand(htmljs, parentView), textMode);\n    };\n\n    /**\n     * @summary Returns the current data context, or the data context that was used when rendering a particular DOM element or View from a Meteor template.\n     * @locus Client\n     * @param {DOMElement|Blaze.View} [elementOrView] Optional.  An element that was rendered by a Meteor, or a View.\n     */\n    Blaze.getData = function (elementOrView) {\n      var _theWith$dataVar$get;\n      let theWith;\n      if (!elementOrView) {\n        theWith = Blaze.getView('with');\n      } else if (elementOrView instanceof Blaze.View) {\n        const view = elementOrView;\n        theWith = view.name === 'with' ? view : Blaze.getView(view, 'with');\n      } else if (typeof elementOrView.nodeType === 'number') {\n        if (elementOrView.nodeType !== 1) throw new Error(\"Expected DOM element\");\n        theWith = Blaze.getView(elementOrView, 'with');\n      } else {\n        throw new Error(\"Expected DOM element or View\");\n      }\n      return theWith ? (_theWith$dataVar$get = theWith.dataVar.get()) === null || _theWith$dataVar$get === void 0 ? void 0 : _theWith$dataVar$get.value : null;\n    };\n\n    // For back-compat\n    Blaze.getElementData = function (element) {\n      Blaze._warn(\"Blaze.getElementData has been deprecated.  Use \" + \"Blaze.getData(element) instead.\");\n      if (element.nodeType !== 1) throw new Error(\"Expected DOM element\");\n      return Blaze.getData(element);\n    };\n\n    // Both arguments are optional.\n\n    /**\n     * @summary Gets either the current View, or the View enclosing the given DOM element.\n     * @locus Client\n     * @param {DOMElement} [element] Optional.  If specified, the View enclosing `element` is returned.\n     */\n    Blaze.getView = function (elementOrView, _viewName) {\n      let viewName = _viewName;\n      if (typeof elementOrView === 'string') {\n        // omitted elementOrView; viewName present\n        viewName = elementOrView;\n        elementOrView = null;\n      }\n\n      // We could eventually shorten the code by folding the logic\n      // from the other methods into this method.\n      if (!elementOrView) {\n        return Blaze._getCurrentView(viewName);\n      } else if (elementOrView instanceof Blaze.View) {\n        return Blaze._getParentView(elementOrView, viewName);\n      } else if (typeof elementOrView.nodeType === 'number') {\n        return Blaze._getElementView(elementOrView, viewName);\n      } else {\n        throw new Error(\"Expected DOM element or View\");\n      }\n    };\n\n    // Gets the current view or its nearest ancestor of name\n    // `name`.\n    Blaze._getCurrentView = function (name) {\n      let view = Blaze.currentView;\n      // Better to fail in cases where it doesn't make sense\n      // to use Blaze._getCurrentView().  There will be a current\n      // view anywhere it does.  You can check Blaze.currentView\n      // if you want to know whether there is one or not.\n      if (!view) throw new Error(\"There is no current view\");\n      if (name) {\n        while (view && view.name !== name) view = view.parentView;\n        return view || null;\n      } else {\n        // Blaze._getCurrentView() with no arguments just returns\n        // Blaze.currentView.\n        return view;\n      }\n    };\n    Blaze._getParentView = function (view, name) {\n      let v = view.parentView;\n      if (name) {\n        while (v && v.name !== name) v = v.parentView;\n      }\n      return v || null;\n    };\n    Blaze._getElementView = function (elem, name) {\n      let range = Blaze._DOMRange.forElement(elem);\n      let view = null;\n      while (range && !view) {\n        view = range.view || null;\n        if (!view) {\n          if (range.parentRange) range = range.parentRange;else range = Blaze._DOMRange.forElement(range.parentElement);\n        }\n      }\n      if (name) {\n        while (view && view.name !== name) view = view.parentView;\n        return view || null;\n      } else {\n        return view;\n      }\n    };\n    Blaze._addEventMap = function (view, eventMap, thisInHandler) {\n      thisInHandler = thisInHandler || null;\n      const handles = [];\n      if (!view._domrange) throw new Error(\"View must have a DOMRange\");\n      view._domrange.onAttached(function attached_eventMaps(range, element) {\n        Object.keys(eventMap).forEach(function (spec) {\n          let handler = eventMap[spec];\n          const clauses = spec.split(/,\\s+/);\n          // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\n          clauses.forEach(function (clause) {\n            const parts = clause.split(/\\s+/);\n            if (parts.length === 0) return;\n            const newEvents = parts.shift();\n            const selector = parts.join(' ');\n            handles.push(Blaze._EventSupport.listen(element, newEvents, selector, function (evt) {\n              if (!range.containsElement(evt.currentTarget, selector, newEvents)) return null;\n              const handlerThis = thisInHandler || this;\n              const handlerArgs = arguments;\n              return Blaze._withCurrentView(view, function () {\n                return handler.apply(handlerThis, handlerArgs);\n              });\n            }, range, function (r) {\n              return r.parentRange;\n            }));\n          });\n        });\n      });\n      view.onViewDestroyed(function () {\n        handles.forEach(function (h) {\n          h.stop();\n        });\n        handles.length = 0;\n      });\n    };\n    __reify_async_result__();\n  } catch (_reifyError) {\n    return __reify_async_result__(_reifyError);\n  }\n  __reify_async_result__()\n}, {\n  self: this,\n  async: false\n});","map":{"version":3,"names":["HTML","module","link","v","__reifyWaitForDeps__","Blaze","View","name","render","_render","_callbacks","created","rendered","destroyed","isCreated","_isCreatedForExpansion","isRendered","_isAttached","isDestroyed","_isInRender","parentView","_domrange","_hasGeneratedParent","_scopeBindings","renderCount","prototype","onViewCreated","cb","push","_onViewRendered","onViewReady","self","fire","Tracker","afterFlush","_withCurrentView","call","onViewRendered","attached","onAttached","onViewDestroyed","removeViewDestroyedListener","index","lastIndexOf","autorun","f","_inViewScope","displayName","Error","templateInstanceFunc","Template","_currentTemplateInstanceFunc","func","viewAutorun","c","_withTemplateInstanceFunc","comp","stopComputation","stop","onStop","_errorIfShouldntCallSubscribe","subscribe","args","options","subHandle","connection","apply","Meteor","firstNode","lastNode","_fireCallbacks","view","which","nonreactive","fireCallbacks","cbs","i","N","length","_createView","forExpansion","doFirstRender","initialContent","domrange","_DOMRange","teardownHook","range","element","_DOMBackend","Teardown","onElementTeardown","teardown","_destroyView","_materializeView","_workStack","_intoArray","lastHtmljs","doRender","htmljs","firstRun","_isContentEqual","doMaterialize","rangesAndNodes","_materializeDOM","setMembers","onInvalidate","destroyMembers","undefined","initialContents","_bind","_expandView","result","_expand","active","_HTMLJSExpander","TransformingVisitor","extend","def","visitObject","x","constructView","visitAttributes","attrs","visitAttribute","value","tag","currentViewIfRendering","currentView","visit","_expandAttributes","expanded","_skipNodes","_destroyNode","node","nodeType","tearDownElement","a","b","Raw","oldView","checkRenderContent","content","Visitor","e","contentAsView","contentAsFunc","__rootViews","parentElement","nextNode","_warn","indexOf","splice","attach","insert","renderWithData","data","_TemplateWith","remove","destroy","parentRange","detach","toHTML","toHTMLWithData","_toText","textMode","TEXTMODE","STRING","RCDATA","ATTRIBUTE","toText","getData","elementOrView","_theWith$dataVar$get","theWith","getView","dataVar","get","getElementData","_viewName","viewName","_getCurrentView","_getParentView","_getElementView","elem","forElement","_addEventMap","eventMap","thisInHandler","handles","attached_eventMaps","Object","keys","forEach","spec","handler","clauses","split","clause","parts","newEvents","shift","selector","join","_EventSupport","listen","evt","containsElement","currentTarget","handlerThis","handlerArgs","arguments","r","h","__reify_async_result__","_reifyError","async"],"sources":["packages/blaze/view.js"],"sourcesContent":["/// [new] Blaze.View([name], renderMethod)\n///\n/// Blaze.View is the building block of reactive DOM.  Views have\n/// the following features:\n///\n/// * lifecycle callbacks - Views are created, rendered, and destroyed,\n///   and callbacks can be registered to fire when these things happen.\n///\n/// * parent pointer - A View points to its parentView, which is the\n///   View that caused it to be rendered.  These pointers form a\n///   hierarchy or tree of Views.\n///\n/// * render() method - A View's render() method specifies the DOM\n///   (or HTML) content of the View.  If the method establishes\n///   reactive dependencies, it may be re-run.\n///\n/// * a DOMRange - If a View is rendered to DOM, its position and\n///   extent in the DOM are tracked using a DOMRange object.\n///\n/// When a View is constructed by calling Blaze.View, the View is\n/// not yet considered \"created.\"  It doesn't have a parentView yet,\n/// and no logic has been run to initialize the View.  All real\n/// work is deferred until at least creation time, when the onViewCreated\n/// callbacks are fired, which happens when the View is \"used\" in\n/// some way that requires it to be rendered.\n///\n/// ...more lifecycle stuff\n///\n/// `name` is an optional string tag identifying the View.  The only\n/// time it's used is when looking in the View tree for a View of a\n/// particular name; for example, data contexts are stored on Views\n/// of name \"with\".  Names are also useful when debugging, so in\n/// general it's good for functions that create Views to set the name.\n/// Views associated with templates have names of the form \"Template.foo\".\nimport { HTML } from 'meteor/htmljs';\n\n/**\n * A binding is either `undefined` (pending), `{ error }` (rejected), or\n * `{ value }` (resolved). Synchronous values are immediately resolved (i.e.,\n * `{ value }` is used). The other states are reserved for asynchronous bindings\n * (i.e., values wrapped with `Promise`s).\n * @typedef {{ error: unknown } | { value: unknown } | undefined} Binding\n */\n\n/**\n * @class\n * @summary Constructor for a View, which represents a reactive region of DOM.\n * @locus Client\n * @param {String} [name] Optional.  A name for this type of View.  See [`view.name`](#view_name).\n * @param {Function} renderFunction A function that returns [*renderable content*](#Renderable-Content).  In this function, `this` is bound to the View.\n */\nBlaze.View = function (name, render) {\n  if (! (this instanceof Blaze.View))\n    // called without `new`\n    return new Blaze.View(name, render);\n\n  if (typeof name === 'function') {\n    // omitted \"name\" argument\n    render = name;\n    name = '';\n  }\n  this.name = name;\n  this._render = render;\n\n  this._callbacks = {\n    created: null,\n    rendered: null,\n    destroyed: null\n  };\n\n  // Setting all properties here is good for readability,\n  // and also may help Chrome optimize the code by keeping\n  // the View object from changing shape too much.\n  this.isCreated = false;\n  this._isCreatedForExpansion = false;\n  this.isRendered = false;\n  this._isAttached = false;\n  this.isDestroyed = false;\n  this._isInRender = false;\n  this.parentView = null;\n  this._domrange = null;\n  // This flag is normally set to false except for the cases when view's parent\n  // was generated as part of expanding some syntactic sugar expressions or\n  // methods.\n  // Ex.: Blaze.renderWithData is an equivalent to creating a view with regular\n  // Blaze.render and wrapping it into {{#with data}}{{/with}} view. Since the\n  // users don't know anything about these generated parent views, Blaze needs\n  // this information to be available on views to make smarter decisions. For\n  // example: removing the generated parent view with the view on Blaze.remove.\n  this._hasGeneratedParent = false;\n  // Bindings accessible to children views (via view.lookup('name')) within the\n  // closest template view.\n  /** @type {Record<string, ReactiveVar<Binding>>} */\n  this._scopeBindings = {};\n\n  this.renderCount = 0;\n};\n\nBlaze.View.prototype._render = function () { return null; };\n\nBlaze.View.prototype.onViewCreated = function (cb) {\n  this._callbacks.created = this._callbacks.created || [];\n  this._callbacks.created.push(cb);\n};\n\nBlaze.View.prototype._onViewRendered = function (cb) {\n  this._callbacks.rendered = this._callbacks.rendered || [];\n  this._callbacks.rendered.push(cb);\n};\n\nBlaze.View.prototype.onViewReady = function (cb) {\n  const self = this;\n  const fire = function () {\n    Tracker.afterFlush(function () {\n      if (! self.isDestroyed) {\n        Blaze._withCurrentView(self, function () {\n          cb.call(self);\n        });\n      }\n    });\n  };\n  self._onViewRendered(function onViewRendered() {\n    if (self.isDestroyed)\n      return;\n    if (! self._domrange.attached)\n      self._domrange.onAttached(fire);\n    else\n      fire();\n  });\n};\n\nBlaze.View.prototype.onViewDestroyed = function (cb) {\n  this._callbacks.destroyed = this._callbacks.destroyed || [];\n  this._callbacks.destroyed.push(cb);\n};\nBlaze.View.prototype.removeViewDestroyedListener = function (cb) {\n  const destroyed = this._callbacks.destroyed;\n  if (! destroyed)\n    return;\n  const index = destroyed.lastIndexOf(cb);\n  if (index !== -1) {\n    // XXX You'd think the right thing to do would be splice, but _fireCallbacks\n    // gets sad if you remove callbacks while iterating over the list.  Should\n    // change this to use callback-hook or EventEmitter or something else that\n    // properly supports removal.\n    destroyed[index] = null;\n  }\n};\n\n/// View#autorun(func)\n///\n/// Sets up a Tracker autorun that is \"scoped\" to this View in two\n/// important ways: 1) Blaze.currentView is automatically set\n/// on every re-run, and 2) the autorun is stopped when the\n/// View is destroyed.  As with Tracker.autorun, the first run of\n/// the function is immediate, and a Computation object that can\n/// be used to stop the autorun is returned.\n///\n/// View#autorun is meant to be called from View callbacks like\n/// onViewCreated, or from outside the rendering process.  It may not\n/// be called before the onViewCreated callbacks are fired (too early),\n/// or from a render() method (too confusing).\n///\n/// Typically, autoruns that update the state\n/// of the View (as in Blaze.With) should be started from an onViewCreated\n/// callback.  Autoruns that update the DOM should be started\n/// from either onViewCreated (guarded against the absence of\n/// view._domrange), or onViewReady.\nBlaze.View.prototype.autorun = function (f, _inViewScope, displayName) {\n  const self = this;\n\n  // The restrictions on when View#autorun can be called are in order\n  // to avoid bad patterns, like creating a Blaze.View and immediately\n  // calling autorun on it.  A freshly created View is not ready to\n  // have logic run on it; it doesn't have a parentView, for example.\n  // It's when the View is materialized or expanded that the onViewCreated\n  // handlers are fired and the View starts up.\n  //\n  // Letting the render() method call `this.autorun()` is problematic\n  // because of re-render.  The best we can do is to stop the old\n  // autorun and start a new one for each render, but that's a pattern\n  // we try to avoid internally because it leads to helpers being\n  // called extra times, in the case where the autorun causes the\n  // view to re-render (and thus the autorun to be torn down and a\n  // new one established).\n  //\n  // We could lift these restrictions in various ways.  One interesting\n  // idea is to allow you to call `view.autorun` after instantiating\n  // `view`, and automatically wrap it in `view.onViewCreated`, deferring\n  // the autorun so that it starts at an appropriate time.  However,\n  // then we can't return the Computation object to the caller, because\n  // it doesn't exist yet.\n  if (! self.isCreated) {\n    throw new Error(\"View#autorun must be called from the created callback at the earliest\");\n  }\n  if (this._isInRender) {\n    throw new Error(\"Can't call View#autorun from inside render(); try calling it from the created or rendered callback\");\n  }\n\n  const templateInstanceFunc = Blaze.Template._currentTemplateInstanceFunc;\n\n  const func = function viewAutorun(c) {\n    return Blaze._withCurrentView(_inViewScope || self, function () {\n      return Blaze.Template._withTemplateInstanceFunc(\n        templateInstanceFunc, function () {\n          return f.call(self, c);\n        });\n    });\n  };\n\n  // Give the autorun function a better name for debugging and profiling.\n  // The `displayName` property is not part of the spec but browsers like Chrome\n  // and Firefox prefer it in debuggers over the name function was declared by.\n  func.displayName =\n    (self.name || 'anonymous') + ':' + (displayName || 'anonymous');\n  const comp = Tracker.autorun(func);\n\n  const stopComputation = function () { comp.stop(); };\n  self.onViewDestroyed(stopComputation);\n  comp.onStop(function () {\n    self.removeViewDestroyedListener(stopComputation);\n  });\n\n  return comp;\n};\n\nBlaze.View.prototype._errorIfShouldntCallSubscribe = function () {\n  const self = this;\n\n  if (! self.isCreated) {\n    throw new Error(\"View#subscribe must be called from the created callback at the earliest\");\n  }\n  if (self._isInRender) {\n    throw new Error(\"Can't call View#subscribe from inside render(); try calling it from the created or rendered callback\");\n  }\n  if (self.isDestroyed) {\n    throw new Error(\"Can't call View#subscribe from inside the destroyed callback, try calling it inside created or rendered.\");\n  }\n};\n\n/**\n * Just like Blaze.View#autorun, but with Meteor.subscribe instead of\n * Tracker.autorun. Stop the subscription when the view is destroyed.\n * @return {SubscriptionHandle} A handle to the subscription so that you can\n * see if it is ready, or stop it manually\n */\nBlaze.View.prototype.subscribe = function (args, options) {\n  const self = this;\n  options = options || {};\n\n  self._errorIfShouldntCallSubscribe();\n\n  let subHandle;\n  if (options.connection) {\n    subHandle = options.connection.subscribe.apply(options.connection, args);\n  } else {\n    subHandle = Meteor.subscribe.apply(Meteor, args);\n  }\n\n  self.onViewDestroyed(function () {\n    subHandle.stop();\n  });\n\n  return subHandle;\n};\n\nBlaze.View.prototype.firstNode = function () {\n  if (! this._isAttached)\n    throw new Error(\"View must be attached before accessing its DOM\");\n\n  return this._domrange.firstNode();\n};\n\nBlaze.View.prototype.lastNode = function () {\n  if (! this._isAttached)\n    throw new Error(\"View must be attached before accessing its DOM\");\n\n  return this._domrange.lastNode();\n};\n\nBlaze._fireCallbacks = function (view, which) {\n  Blaze._withCurrentView(view, function () {\n    Tracker.nonreactive(function fireCallbacks() {\n      const cbs = view._callbacks[which];\n      for (let i = 0, N = (cbs && cbs.length); i < N; i++)\n        cbs[i] && cbs[i].call(view);\n    });\n  });\n};\n\nBlaze._createView = function (view, parentView, forExpansion) {\n  if (view.isCreated)\n    throw new Error(\"Can't render the same View twice\");\n\n  view.parentView = (parentView || null);\n  view.isCreated = true;\n  if (forExpansion)\n    view._isCreatedForExpansion = true;\n\n  Blaze._fireCallbacks(view, 'created');\n};\n\nconst doFirstRender = function (view, initialContent) {\n  const domrange = new Blaze._DOMRange(initialContent);\n  view._domrange = domrange;\n  domrange.view = view;\n  view.isRendered = true;\n  Blaze._fireCallbacks(view, 'rendered');\n\n  let teardownHook = null;\n\n  domrange.onAttached(function attached(range, element) {\n    view._isAttached = true;\n\n    teardownHook = Blaze._DOMBackend.Teardown.onElementTeardown(\n      element, function teardown() {\n        Blaze._destroyView(view, true /* _skipNodes */);\n      });\n  });\n\n  // tear down the teardown hook\n  view.onViewDestroyed(function () {\n    if (teardownHook) teardownHook.stop();\n    teardownHook = null;\n  });\n\n  return domrange;\n};\n\n// Take an uncreated View `view` and create and render it to DOM,\n// setting up the autorun that updates the View.  Returns a new\n// DOMRange, which has been associated with the View.\n//\n// The private arguments `_workStack` and `_intoArray` are passed in\n// by Blaze._materializeDOM and are only present for recursive calls\n// (when there is some other _materializeView on the stack).  If\n// provided, then we avoid the mutual recursion of calling back into\n// Blaze._materializeDOM so that deep View hierarchies don't blow the\n// stack.  Instead, we push tasks onto workStack for the initial\n// rendering and subsequent setup of the View, and they are done after\n// we return.  When there is a _workStack, we do not return the new\n// DOMRange, but instead push it into _intoArray from a _workStack\n// task.\nBlaze._materializeView = function (view, parentView, _workStack, _intoArray) {\n  Blaze._createView(view, parentView);\n\n  let domrange;\n  let lastHtmljs;\n  // We don't expect to be called in a Computation, but just in case,\n  // wrap in Tracker.nonreactive.\n  Tracker.nonreactive(function () {\n    view.autorun(function doRender(c) {\n      // `view.autorun` sets the current view.\n      view.renderCount = view.renderCount + 1;\n      view._isInRender = true;\n      // Any dependencies that should invalidate this Computation come\n      // from this line:\n      const htmljs = view._render();\n      view._isInRender = false;\n\n      if (! c.firstRun && ! Blaze._isContentEqual(lastHtmljs, htmljs)) {\n        Tracker.nonreactive(function doMaterialize() {\n          // re-render\n          const rangesAndNodes = Blaze._materializeDOM(htmljs, [], view);\n          domrange.setMembers(rangesAndNodes);\n          Blaze._fireCallbacks(view, 'rendered');\n        });\n      }\n      lastHtmljs = htmljs;\n\n      // Causes any nested views to stop immediately, not when we call\n      // `setMembers` the next time around the autorun.  Otherwise,\n      // helpers in the DOM tree to be replaced might be scheduled\n      // to re-run before we have a chance to stop them.\n      Tracker.onInvalidate(function () {\n        if (domrange) {\n          domrange.destroyMembers();\n        }\n      });\n    }, undefined, 'materialize');\n\n    // first render.  lastHtmljs is the first htmljs.\n    let initialContents;\n    if (! _workStack) {\n      initialContents = Blaze._materializeDOM(lastHtmljs, [], view);\n      domrange = doFirstRender(view, initialContents);\n      initialContents = null; // help GC because we close over this scope a lot\n    } else {\n      // We're being called from Blaze._materializeDOM, so to avoid\n      // recursion and save stack space, provide a description of the\n      // work to be done instead of doing it.  Tasks pushed onto\n      // _workStack will be done in LIFO order after we return.\n      // The work will still be done within a Tracker.nonreactive,\n      // because it will be done by some call to Blaze._materializeDOM\n      // (which is always called in a Tracker.nonreactive).\n      initialContents = [];\n      // push this function first so that it happens last\n      _workStack.push(function () {\n        domrange = doFirstRender(view, initialContents);\n        initialContents = null; // help GC because of all the closures here\n        _intoArray.push(domrange);\n      });\n      // now push the task that calculates initialContents\n      _workStack.push(Blaze._bind(Blaze._materializeDOM, null,\n                             lastHtmljs, initialContents, view, _workStack));\n    }\n  });\n\n  if (! _workStack) {\n    return domrange;\n  } else {\n    return null;\n  }\n};\n\n// Expands a View to HTMLjs, calling `render` recursively on all\n// Views and evaluating any dynamic attributes.  Calls the `created`\n// callback, but not the `materialized` or `rendered` callbacks.\n// Destroys the view immediately, unless called in a Tracker Computation,\n// in which case the view will be destroyed when the Computation is\n// invalidated.  If called in a Tracker Computation, the result is a\n// reactive string; that is, the Computation will be invalidated\n// if any changes are made to the view or subviews that might affect\n// the HTML.\nBlaze._expandView = function (view, parentView) {\n  Blaze._createView(view, parentView, true /*forExpansion*/);\n\n  view._isInRender = true;\n  const htmljs = Blaze._withCurrentView(view, function () {\n    return view._render();\n  });\n  view._isInRender = false;\n\n  const result = Blaze._expand(htmljs, view);\n\n  if (Tracker.active) {\n    Tracker.onInvalidate(function () {\n      Blaze._destroyView(view);\n    });\n  } else {\n    Blaze._destroyView(view);\n  }\n\n  return result;\n};\n\n// Options: `parentView`\nBlaze._HTMLJSExpander = HTML.TransformingVisitor.extend();\nBlaze._HTMLJSExpander.def({\n  visitObject: function (x) {\n    if (x instanceof Blaze.Template)\n      x = x.constructView();\n    if (x instanceof Blaze.View)\n      return Blaze._expandView(x, this.parentView);\n\n    // this will throw an error; other objects are not allowed!\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n  },\n  visitAttributes: function (attrs) {\n    // expand dynamic attributes\n    if (typeof attrs === 'function')\n      attrs = Blaze._withCurrentView(this.parentView, attrs);\n\n    // call super (e.g. for case where `attrs` is an array)\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\n  },\n  visitAttribute: function (name, value, tag) {\n    // expand attribute values that are functions.  Any attribute value\n    // that contains Views must be wrapped in a function.\n    if (typeof value === 'function')\n      value = Blaze._withCurrentView(this.parentView, value);\n\n    return HTML.TransformingVisitor.prototype.visitAttribute.call(\n      this, name, value, tag);\n  }\n});\n\n// Return Blaze.currentView, but only if it is being rendered\n// (i.e. we are in its render() method).\nconst currentViewIfRendering = function () {\n  const view = Blaze.currentView;\n  return (view && view._isInRender) ? view : null;\n};\n\nBlaze._expand = function (htmljs, parentView) {\n  parentView = parentView || currentViewIfRendering();\n  return (new Blaze._HTMLJSExpander(\n    {parentView: parentView})).visit(htmljs);\n};\n\nBlaze._expandAttributes = function (attrs, parentView) {\n  parentView = parentView || currentViewIfRendering();\n  const expanded = (new Blaze._HTMLJSExpander(\n    {parentView: parentView})).visitAttributes(attrs);\n  return expanded || {};\n};\n\nBlaze._destroyView = function (view, _skipNodes) {\n  if (view.isDestroyed)\n    return;\n  view.isDestroyed = true;\n\n\n  // Destroy views and elements recursively.  If _skipNodes,\n  // only recurse up to views, not elements, for the case where\n  // the backend (jQuery) is recursing over the elements already.\n\n  if (view._domrange) view._domrange.destroyMembers(_skipNodes);\n\n  // XXX: fire callbacks after potential members are destroyed\n  // otherwise it's tracker.flush will cause the above line will\n  // not be called and their views won't be destroyed\n  // Involved issues: DOMRange \"Must be attached\" error, mem leak\n\n  Blaze._fireCallbacks(view, 'destroyed');\n};\n\nBlaze._destroyNode = function (node) {\n  if (node.nodeType === 1)\n    Blaze._DOMBackend.Teardown.tearDownElement(node);\n};\n\n// Are the HTMLjs entities `a` and `b` the same?  We could be\n// more elaborate here but the point is to catch the most basic\n// cases.\nBlaze._isContentEqual = function (a, b) {\n  if (a instanceof HTML.Raw) {\n    return (b instanceof HTML.Raw) && (a.value === b.value);\n  } else if (a == null) {\n    return (b == null);\n  } else {\n    return (a === b) &&\n      ((typeof a === 'number') || (typeof a === 'boolean') ||\n       (typeof a === 'string'));\n  }\n};\n\n/**\n * @summary The View corresponding to the current template helper, event handler, callback, or autorun.  If there isn't one, `null`.\n * @locus Client\n * @type {Blaze.View}\n */\nBlaze.currentView = null;\n\n/**\n * @template T\n * @param {Blaze.View} view\n * @param {function(): T} func\n * @returns {T}\n */\nBlaze._withCurrentView = function (view, func) {\n  const oldView = Blaze.currentView;\n  try {\n    Blaze.currentView = view;\n    return func();\n  } finally {\n    Blaze.currentView = oldView;\n  }\n};\n\n// Blaze.render publicly takes a View or a Template.\n// Privately, it takes any HTMLJS (extended with Views and Templates)\n// except null or undefined, or a function that returns any extended\n// HTMLJS.\nconst checkRenderContent = function (content) {\n  if (content === null)\n    throw new Error(\"Can't render null\");\n  if (typeof content === 'undefined')\n    throw new Error(\"Can't render undefined\");\n\n  if ((content instanceof Blaze.View) ||\n      (content instanceof Blaze.Template) ||\n      (typeof content === 'function'))\n    return;\n\n  try {\n    // Throw if content doesn't look like HTMLJS at the top level\n    // (i.e. verify that this is an HTML.Tag, or an array,\n    // or a primitive, etc.)\n    (new HTML.Visitor).visit(content);\n  } catch (e) {\n    // Make error message suitable for public API\n    throw new Error(\"Expected Template or View\");\n  }\n};\n\n// For Blaze.render and Blaze.toHTML, take content and\n// wrap it in a View, unless it's a single View or\n// Template already.\nconst contentAsView = function (content) {\n  checkRenderContent(content);\n\n  if (content instanceof Blaze.Template) {\n    return content.constructView();\n  } else if (content instanceof Blaze.View) {\n    return content;\n  } else {\n    let func = content;\n    if (typeof func !== 'function') {\n      func = function () {\n        return content;\n      };\n    }\n    return Blaze.View('render', func);\n  }\n};\n\n// For Blaze.renderWithData and Blaze.toHTMLWithData, wrap content\n// in a function, if necessary, so it can be a content arg to\n// a Blaze.With.\nconst contentAsFunc = function (content) {\n  checkRenderContent(content);\n\n  if (typeof content !== 'function') {\n    return function () {\n      return content;\n    };\n  } else {\n    return content;\n  }\n};\n\nBlaze.__rootViews = [];\n\n/**\n * @summary Renders a template or View to DOM nodes and inserts it into the DOM, returning a rendered [View](#Blaze-View) which can be passed to [`Blaze.remove`](#Blaze-remove).\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.  If a template, a View object is [constructed](#template_constructview).  If a View, it must be an unrendered View, which becomes a rendered View and is returned.\n * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n */\nBlaze.render = function (content, parentElement, nextNode, parentView) {\n  if (! parentElement) {\n    Blaze._warn(\"Blaze.render without a parent element is deprecated. \" +\n                \"You must specify where to insert the rendered content.\");\n  }\n\n  if (nextNode instanceof Blaze.View) {\n    // handle omitted nextNode\n    parentView = nextNode;\n    nextNode = null;\n  }\n\n  // parentElement must be a DOM node. in particular, can't be the\n  // result of a call to `$`. Can't check if `parentElement instanceof\n  // Node` since 'Node' is undefined in IE8.\n  if (parentElement && typeof parentElement.nodeType !== 'number')\n    throw new Error(\"'parentElement' must be a DOM node\");\n  if (nextNode && typeof nextNode.nodeType !== 'number') // 'nextNode' is optional\n    throw new Error(\"'nextNode' must be a DOM node\");\n\n  parentView = parentView || currentViewIfRendering();\n\n  const view = contentAsView(content);\n\n  // TODO: this is only needed in development\n  if (!parentView) {\n    view.onViewCreated(function () {\n      Blaze.__rootViews.push(view);\n    });\n\n    view.onViewDestroyed(function () {\n      let index = Blaze.__rootViews.indexOf(view);\n      if (index > -1) {\n        Blaze.__rootViews.splice(index, 1);\n      }\n    });\n  }\n\n  Blaze._materializeView(view, parentView);\n  if (parentElement) {\n    view._domrange.attach(parentElement, nextNode);\n  }\n\n  return view;\n};\n\nBlaze.insert = function (view, parentElement, nextNode) {\n  Blaze._warn(\"Blaze.insert has been deprecated.  Specify where to insert the \" +\n              \"rendered content in the call to Blaze.render.\");\n\n  if (! (view && (view._domrange instanceof Blaze._DOMRange)))\n    throw new Error(\"Expected template rendered with Blaze.render\");\n\n  view._domrange.attach(parentElement, nextNode);\n};\n\n/**\n * @summary Renders a template or View to DOM nodes with a data context.  Otherwise identical to `Blaze.render`.\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.\n * @param {Object|Function} data The data context to use, or a function returning a data context.  If a function is provided, it will be reactively re-run.\n * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n */\nBlaze.renderWithData = function (content, data, parentElement, nextNode, parentView) {\n  // We defer the handling of optional arguments to Blaze.render.  At this point,\n  // `nextNode` may actually be `parentView`.\n  return Blaze.render(Blaze._TemplateWith(data, contentAsFunc(content)),\n                          parentElement, nextNode, parentView);\n};\n\n/**\n * @summary Removes a rendered View from the DOM, stopping all reactive updates and event listeners on it. Also destroys the Blaze.Template instance associated with the view.\n * @locus Client\n * @param {Blaze.View} renderedView The return value from `Blaze.render` or `Blaze.renderWithData`, or the `view` property of a Blaze.Template instance. Calling `Blaze.remove(Template.instance().view)` from within a template event handler will destroy the view as well as that template and trigger the template's `onDestroyed` handlers.\n */\nBlaze.remove = function (view) {\n  if (! (view && (view._domrange instanceof Blaze._DOMRange)))\n    throw new Error(\"Expected template rendered with Blaze.render\");\n\n  while (view) {\n    if (! view.isDestroyed) {\n      const range = view._domrange;\n      range.destroy();\n\n      if (range.attached && ! range.parentRange) {\n        range.detach();\n      }\n    }\n\n    view = view._hasGeneratedParent && view.parentView;\n  }\n};\n\n/**\n * @summary Renders a template or View to a string of HTML.\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n */\nBlaze.toHTML = function (content, parentView) {\n  parentView = parentView || currentViewIfRendering();\n\n  return HTML.toHTML(Blaze._expandView(contentAsView(content), parentView));\n};\n\n/**\n * @summary Renders a template or View to HTML with a data context.  Otherwise identical to `Blaze.toHTML`.\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n * @param {Object|Function} data The data context to use, or a function returning a data context.\n */\nBlaze.toHTMLWithData = function (content, data, parentView) {\n  parentView = parentView || currentViewIfRendering();\n\n  return HTML.toHTML(Blaze._expandView(Blaze._TemplateWith(\n    data, contentAsFunc(content)), parentView));\n};\n\nBlaze._toText = function (htmljs, parentView, textMode) {\n  if (typeof htmljs === 'function')\n    throw new Error(\"Blaze._toText doesn't take a function, just HTMLjs\");\n\n  if ((parentView != null) && ! (parentView instanceof Blaze.View)) {\n    // omitted parentView argument\n    textMode = parentView;\n    parentView = null;\n  }\n  parentView = parentView || currentViewIfRendering();\n\n  if (! textMode)\n    throw new Error(\"textMode required\");\n  if (! (textMode === HTML.TEXTMODE.STRING ||\n         textMode === HTML.TEXTMODE.RCDATA ||\n         textMode === HTML.TEXTMODE.ATTRIBUTE))\n    throw new Error(\"Unknown textMode: \" + textMode);\n\n  return HTML.toText(Blaze._expand(htmljs, parentView), textMode);\n};\n\n/**\n * @summary Returns the current data context, or the data context that was used when rendering a particular DOM element or View from a Meteor template.\n * @locus Client\n * @param {DOMElement|Blaze.View} [elementOrView] Optional.  An element that was rendered by a Meteor, or a View.\n */\nBlaze.getData = function (elementOrView) {\n  let theWith;\n\n  if (! elementOrView) {\n    theWith = Blaze.getView('with');\n  } else if (elementOrView instanceof Blaze.View) {\n    const view = elementOrView;\n    theWith = (view.name === 'with' ? view :\n               Blaze.getView(view, 'with'));\n  } else if (typeof elementOrView.nodeType === 'number') {\n    if (elementOrView.nodeType !== 1)\n      throw new Error(\"Expected DOM element\");\n    theWith = Blaze.getView(elementOrView, 'with');\n  } else {\n    throw new Error(\"Expected DOM element or View\");\n  }\n\n  return theWith ? theWith.dataVar.get()?.value : null;\n};\n\n// For back-compat\nBlaze.getElementData = function (element) {\n  Blaze._warn(\"Blaze.getElementData has been deprecated.  Use \" +\n              \"Blaze.getData(element) instead.\");\n\n  if (element.nodeType !== 1)\n    throw new Error(\"Expected DOM element\");\n\n  return Blaze.getData(element);\n};\n\n// Both arguments are optional.\n\n/**\n * @summary Gets either the current View, or the View enclosing the given DOM element.\n * @locus Client\n * @param {DOMElement} [element] Optional.  If specified, the View enclosing `element` is returned.\n */\nBlaze.getView = function (elementOrView, _viewName) {\n  let viewName = _viewName;\n\n  if ((typeof elementOrView) === 'string') {\n    // omitted elementOrView; viewName present\n    viewName = elementOrView;\n    elementOrView = null;\n  }\n\n  // We could eventually shorten the code by folding the logic\n  // from the other methods into this method.\n  if (! elementOrView) {\n    return Blaze._getCurrentView(viewName);\n  } else if (elementOrView instanceof Blaze.View) {\n    return Blaze._getParentView(elementOrView, viewName);\n  } else if (typeof elementOrView.nodeType === 'number') {\n    return Blaze._getElementView(elementOrView, viewName);\n  } else {\n    throw new Error(\"Expected DOM element or View\");\n  }\n};\n\n// Gets the current view or its nearest ancestor of name\n// `name`.\nBlaze._getCurrentView = function (name) {\n  let view = Blaze.currentView;\n  // Better to fail in cases where it doesn't make sense\n  // to use Blaze._getCurrentView().  There will be a current\n  // view anywhere it does.  You can check Blaze.currentView\n  // if you want to know whether there is one or not.\n  if (! view)\n    throw new Error(\"There is no current view\");\n\n  if (name) {\n    while (view && view.name !== name)\n      view = view.parentView;\n    return view || null;\n  } else {\n    // Blaze._getCurrentView() with no arguments just returns\n    // Blaze.currentView.\n    return view;\n  }\n};\n\nBlaze._getParentView = function (view, name) {\n  let v = view.parentView;\n\n  if (name) {\n    while (v && v.name !== name)\n      v = v.parentView;\n  }\n\n  return v || null;\n};\n\nBlaze._getElementView = function (elem, name) {\n  let range = Blaze._DOMRange.forElement(elem);\n  let view = null;\n  while (range && ! view) {\n    view = (range.view || null);\n    if (! view) {\n      if (range.parentRange)\n        range = range.parentRange;\n      else\n        range = Blaze._DOMRange.forElement(range.parentElement);\n    }\n  }\n\n  if (name) {\n    while (view && view.name !== name)\n      view = view.parentView;\n    return view || null;\n  } else {\n    return view;\n  }\n};\n\nBlaze._addEventMap = function (view, eventMap, thisInHandler) {\n  thisInHandler = (thisInHandler || null);\n  const handles = [];\n\n  if (! view._domrange)\n    throw new Error(\"View must have a DOMRange\");\n\n  view._domrange.onAttached(function attached_eventMaps(range, element) {\n    Object.keys(eventMap).forEach(function (spec) {\n      let handler = eventMap[spec];\n      const clauses = spec.split(/,\\s+/);\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\n      clauses.forEach(function (clause) {\n        const parts = clause.split(/\\s+/);\n        if (parts.length === 0)\n          return;\n\n        const newEvents = parts.shift();\n        const selector = parts.join(' ');\n        handles.push(Blaze._EventSupport.listen(\n          element, newEvents, selector,\n          function (evt) {\n            if (! range.containsElement(evt.currentTarget, selector, newEvents))\n              return null;\n            const handlerThis = thisInHandler || this;\n            const handlerArgs = arguments;\n            return Blaze._withCurrentView(view, function () {\n              return handler.apply(handlerThis, handlerArgs);\n            });\n          },\n          range, function (r) {\n            return r.parentRange;\n          }));\n      });\n    });\n  });\n\n  view.onViewDestroyed(function () {\n    handles.forEach(function (h) {\n      h.stop();\n    });\n    handles.length = 0;\n  });\n};\n"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"cd0176ad1b615314b1ce5b94eb17629f429ca8b1"}
